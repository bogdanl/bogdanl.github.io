<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>mirrorsin.space</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- <link href="css/main.css" rel="stylesheet"> -->
    <style>
    head, body{
        width:100%;
        height:100%;
        overflow: hidden;
        top:0;
        left:0;
        margin:0;
        padding:0;
        cursor: url('css/chaos-magick.png'), auto;
        font-family: optima;
        color: white;
        text-align: justify;
    }
    #title {
        position: absolute;
        left: 10px;
        bottom: 10px;
        cursor: url('css/chaos-magick.png'), auto;
        width: 330px;
        text-align: justify;
        text-align-last: justify;
        text-justify: inter-word;
    }
    #instructions {
        position: absolute;
        font-family: optima;
        right: 10px;
        bottom: 10px;
        width: 290px;
        text-align: justify;
        text-align-last: justify;
        text-justify: inter-word;
        text-transform: uppercase;
    }
    #volume {
        position: absolute;
        top: 3px;
        left: 3px;
        font-size: 13px;
        font-style: bold;
        cursor: pointer;
    }
    #fullscreen {
        position: absolute;
        top: 3px;
        right: 3px;
        text-transform: uppercase;
        cursor: pointer;
    }
</style>
</head>
<body>
    <div id="fullscreen">fullscreen</div>
    <div id="title">
        <strong>mirrors in space â˜· coming soon</strong> to be outlived<br>
        by the stairs free falling into the running water<br>
        the stars rolling away from each other<br>
        outshone by silhouettes on fortuitous placards<br>
        & out of sight; forgetful of its smeared desires
    </div>
    <div id="instructions">
        <strong>arrows</strong> to change the mirrors<br>
        <strong>space bar</strong> to toggle rotation<br>
        <strong>drag, click, scroll</strong> to interact
    </div>
    <div id="volume">TURN SOUND ON</div>

    <div id="container"></div>

    <script src="vendor/three.min.js"></script>
    <script src="vendor/OrbitControls.js"></script>
    <script src="ShaderLoader.js"></script>
    <script src="fbo.js"></script>
    <script src="vid360.js"></script>
    <script src="vendor/three-bmfont.js"></script>
    <script src="vendor/load-bmfont.js"></script>
    <script src="vendor/TweenMax.min.js"></script>
    <script src="hyperspace.js"></script>

    <script type="module">
        import {EffectComposer} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/EffectComposer.js';
        import {RenderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/RenderPass.js';
        import {ShaderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/ShaderPass.js';
        import {Reflector} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/objects/Reflector.js';
        import {Curves} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/curves/CurveExtras.js';

        var scene, camera, renderer, composer, controls, timer=0, timerInc=.01;
        var simulationShader, renderShader, kaleidoscopePass;
        var soundOn=false, audioLoader, soundObj;

        var glimpsing = false, glimpseLength = 1, amplInc = 0.11, amplDec = 0.08;
        var texture, video, videoMaterial, defaultTexture;
        var imgUrls = ['ourobouros.jpeg', 'ourobouros2.jpeg', 'sigil.jpeg', 'astro.jpeg', 'focus.jpeg', 'solar.jpeg']
        var imgs = [];
        var videoPlaying = false, kaleidoing = false;
        var listener, volumeButton;

        var textMaterial, textGeometry, textMesh, textAnchor, font, fontTexture, alphabeting, alphabetDuration = 0.5;
        var cameraCube, sceneCube;

        // var vids = {
        //     // thornhill1: 'https://content.jwplatform.com/videos/uyV9eWMN-ac7wx05Q.mp4',
        //     // thornhill2: 'https://content.jwplatform.com/videos/pefTTpeR-yhiBISfO.mp4'
        //     thornhill1: 'vid/thornhill1.webm',
        //     thornhill2: 'vid/thornhill2.webm',
        //     barber: 'vid/barber.webm',
        //     bus: 'vid/bus.webm',
        //     petrol: 'vid/petrol.webm',
        //     wasserturm1: 'vid/wasserturm1.webm',
        //     wasserturm2: 'vid/wasserturm2.webm',
        // };        

        var vids = {
            thornhill1: 'https://content.jwplatform.com/videos/uyV9eWMN-ac7wx05Q.mp4',
            thornhill2: 'https://content.jwplatform.com/videos/pefTTpeR-yhiBISfO.mp4',
            barber: 'https://content.jwplatform.com/videos/jzY7TFVz-yhiBISfO.mp4',
            bus: 'https://content.jwplatform.com/videos/RTJiWoIP-yhiBISfO.mp4',
            petrol: 'https://content.jwplatform.com/videos/MlbrvHu9-yhiBISfO.mp4',
            wasserturm1: 'https://content.jwplatform.com/videos/2XjjGkh9-yhiBISfO.mp4',
            wasserturm2: 'https://content.jwplatform.com/videos/vAvPamCv-yhiBISfO.mp4',
        };

        window.onload = function() {
            var sl = new ShaderLoader();
            sl.loadShaders({
                noise_simulationVS : "",
                noise_simulationFS : "",
                noise_renderVS : "",
                noise_renderFS : "",                
                bmfont_frag : "",
                bmfont_vert : "",
            }, "./glsl/", init );
        };

        function rndItem(arr) {
            return arr[THREE.Math.randInt(0, arr.length - 1)];
        }

        function playSound(name, fadeIn, fadeOut) {
            if (name === 'sky') {
                name = rndItem(['hc', 'meditation', 'aleksi']);
            } else if (name === 'transition') {
                name = rndItem(['coil', 'cio', 'elaine']);
            } else if (name === 'video') {
                name = rndItem(['voices', 'ff', 'thornhill2', 'ff2']);
            }
            if (audioLoader == undefined) {
                audioLoader = new THREE.AudioLoader();
                listener = new THREE.AudioListener();
                camera.add(listener);
            }

            let snd = new THREE.Audio(listener);
            snds[name] = snd;

            audioLoader.load('snd/' + name + '.ogg', function(buffer) {
                volumeButton.style.display = 'block';
                snd.setBuffer(buffer);
                snd.setLoop(true);
                if (soundOn) {
                    snd.play();
                }
            });

            fadeOut = fadeOut || 0;
            fadeIn = fadeIn || 0;

            if (fadeIn > 0) {
                let volume = {x : 0};
                TweenMax.to(volume, fadeIn, {
                    x: 1,
                    onUpdate: function() {
                        snd.setVolume(this.target.x);
                    }
                });
            } else {
                snd.setVolume(1);
            }

            if (fadeOut > 0) {
                let volume = {x : 1};
                var fadeOutSnds = Object.assign({}, snds);
                delete fadeOutSnds[name];

                // if (snds[name] !== undefined) snds.splice(index, 1);
                TweenMax.to(volume, fadeOut, {
                    x: 0,
                    onUpdate: function() {
                        for (const [sndName, snd] of Object.entries(fadeOutSnds)) {
                            if (sndName !== name) {
                                snd.setVolume(this.target.x);
                            }
                        }
                    },
                    onComplete: function() {
                        for (const [sndName, snd] of Object.entries(fadeOutSnds)) {
                            if (sndName !== name)
                                snd.pause();
                        }
                    },
                });
            } else if (fadeOut == 0) {
                var fadeOutSnds = Object.assign({}, snds);
                delete fadeOutSnds[name];
                for (const [sndName, snd] of Object.entries(fadeOutSnds)) {
                    if (sndName !== name)
                        snd.pause();
                }
            }
            return name;
        }

        function onVolumeChange(event) {
            if (!soundOn) {
                soundOn = true;
                for (const [name, snd] of Object.entries(snds)) {
                    snd.play();
                }
                volumeButton.innerHTML = "TURN SOUND OFF";
            } else {
                for (const [name, snd] of Object.entries(snds)) {
                    snd.pause();
                }
                volumeButton.innerHTML = "TURN SOUND ON";
                soundOn = false;
            }
        }

        //returns a Float32Array buffer of random 3D coordinates
        function getRandomData(count, size){
            var len = count * 4;
            var data = new Float32Array(len);
            while(len--) {
                data[len] = (Math.random() - .5) * size;
            }
            return data;
        }

        function getDefaultTexture(width, height, size) {
            let data = getSphere(width * height, size);
            let texture = new THREE.DataTexture(
                data, width, height, THREE.RGBAFormat, THREE.FloatType, THREE.DEFAULT_MAPPING, THREE.MirroredRepeatWrapping, THREE.MirroredRepeatWrapping
                );
            texture.needsUpdate = true;
            return texture;
        }

        function init(args) {
            loadImages(imgUrls).then(images => {
                imgs = images;
                loadFont('fonts/DejaVu-sdf.fnt', function(err, fnt) {
                    font = fnt;
                    let textureLoader = new THREE.TextureLoader();
                    textureLoader.load('fonts/DejaVu-sdf.png', function (texture) {
                        fontTexture = texture;
                        initCont(args);
                    });
                });
            });
        }

        function initCont(args) {
            args = args || {};
            var w = window.innerWidth;
            var h = window.innerHeight;
            renderer = new THREE.WebGLRenderer({
                logarithmicDepthBuffer: true,
                antialias: true
            });
            renderer.setSize(w, h);
            renderer.setClearColor(defaultBackColor);
            renderer.autoClear = false;

            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(100, 0, 0.0001, 10000000);

            controls = new THREE.OrbitControls(camera);
            camera.position.z = 30;
            controls.enableDamping = true;
            controls.maxDistance = 30;
            controls.minDistance = 30;

            cameraCube = new THREE.PerspectiveCamera(100, 0, 0.0001, 10000000);
            sceneCube = new THREE.Scene();
            var ambient = new THREE.AmbientLight(0xffffff);
            sceneCube.add(ambient);

            // create an AudioListener and add it to the camera
            volumeButton = document.getElementById('volume');
            volumeButton.style.display = 'none';

            var ww = 512;
            var width  = args.w || ww;
            var height = args.h || ww;

            // create a geometry of packed bitmap glyphs, 
            // word wrapped to 300px and right-aligned
            textGeometry = bmfont({
                width: 100,
                align: 'center',
                font: font,
                // flipY: true
            });
            // the texture atlas containing our glyphs
            textMaterial = new THREE.RawShaderMaterial({
                vertexShader: ShaderLoader.get("bmfont_vert"),
                fragmentShader: ShaderLoader.get("bmfont_frag"),
                uniforms: {
                    animate: {type: 'f', value: 1.},
                    duration: {type: 'f', value: alphabetDuration},
                    timer: {type: 'f', value: 0.},
                    map: {type: 't', value: fontTexture},
                    color: {type: 'c', value: new THREE.Color(0, 0, 0)}
                },
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false
            });
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            // scale it down so it fits in our 3D units
            textAnchor = new THREE.Object3D();
            // textAnchor.scale.multiplyScalar(-0.005);
            textAnchor.add(textMesh);
            textAnchor.rotation.x = Math.PI;
            scene.add(textAnchor);

            defaultTexture = getDefaultTexture(width, height, args.s || 2000);

            simulationShader = new THREE.ShaderMaterial({
                uniforms: {
                    texture: {type: "t", value: defaultTexture},
                    timer: {type: "f", value: 0},
                    frequency: {type: "f", value: .00032},
                    amplitude: {type: "f", value: 40},
                    maxDistance: {type: "f", value: 40},
                    morph: {type: 'f', value: 0.0},
                    textureDest: {type: "t", value: null},
                    morphTimestamp: {type: 'f', value: null},
                    morphSpeed: {type: 'f', value: 0.1},
                    mouse: {type: "v3", value: new THREE.Vector3(0)},
                    // alphaMap: { type: 't', value: currVid.mesh.material.alphaMap }
                },
                vertexShader: ShaderLoader.get( "noise_simulationVS"),
                fragmentShader:  ShaderLoader.get( "noise_simulationFS"),
            });

            renderShader = new THREE.ShaderMaterial( {
                uniforms: {
                    positions: {type: "t", value: null},
                    pointSize: {type: "f", value: 3},
                    nColor: {type: "v3", value: new THREE.Vector3(1, 1, 1)},
                    big: {type: "v3", value: new THREE.Vector3(207, 221, 212).multiplyScalar(1/0xFF)},
                    small: {type: "v3", value: new THREE.Vector3(213, 239, 229).multiplyScalar(1/0xFF)},
                    timer: {value: timer},
                    mouse: {type: "v3", value: new THREE.Vector3(0)}
                },
                vertexShader: ShaderLoader.get("noise_renderVS"),
                fragmentShader: ShaderLoader.get("noise_renderFS"),
                transparent: true,
                side:THREE.DoubleSide,
            });

            const kaleidoscopeShader = {
                uniforms: {
                  "tDiffuse": {value: null},
                  "sides": {value: 1.},
                  "angle": {value: 0.},
                  "uvOffset": {value: -.5},
                  "diffuseOffset": {value: .5},
                  // 0=sin, 1=cos, 2=tan, 3=atan
                  "trigoX": {value: 0},
                  "trigoY": {value: 1}
                },
                vertexShader: `
                    varying vec2 vUv;

                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float sides;
                    uniform float angle;
                    uniform float uvOffset;
                    uniform float diffuseOffset;
                    uniform int trigoX;
                    uniform int trigoY;

                    varying vec2 vUv;
                    const float tau = 2. * 3.1415926535897932384626433832795;

                    float _trigo(int trigo, float a) {
                        if (trigo == 0)
                            return sin(a);
                        if (trigo == 1)
                            return cos(a);
                        if (trigo == 2)
                            return tan(a);
                        if (trigo == 3)
                            return atan(a);
                    }

                    void main() {
                        vec2 p = vUv + uvOffset;
                        float r = length(p);
                        float a = atan(p.x, p.y) + angle;
                        a = mod(a, tau/sides);
                        a = abs(a - tau/sides/2.);
                        p = r * vec2(_trigo(trigoX, a), _trigo(trigoY, a));
                        vec4 color = texture2D(tDiffuse, p + diffuseOffset);
                        gl_FragColor = color;
                    }
                `
              };

            FBO.init(width, height, renderer, simulationShader, renderShader);

            addDomListeners();

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            kaleidoscopePass = new ShaderPass(kaleidoscopeShader);
            kaleidoscopePass.renderToScreen = true;
            // kaleidoscopePass.enabled = true;
            composer.addPass(kaleidoscopePass);

            currVid = vid360.init(renderer, vids['barber'], Curves, playSound);
            currVid.start();
            videoPlaying = true;
            mainSnd = 'ff';
            playSound(mainSnd);

            sky = new THREE.Group();
            sky.add(FBO.particles);

            floatingVids.push(addFloatingVid('thornhill2'));
            floatingVids.push(addFloatingVid('wasserturm1'));

            remainingVids = ['bus', 'petrol', 'wasserturm2', 'thornhill1'];

            // floatingVids.push(addFloatingVid('thornhill1'));
            // floatingVids.push(addFloatingVid('bus'));
            // floatingVids.push(addFloatingVid('petrol'));
            // floatingVids.push(addFloatingVid('barber'));

            scene.add(sky);

            // whatDoYouSee();

            onResize();
            update();
        }

        var floatingVids = [], currVid, sky;
        var lastVideo, remainingVids = [], vidCount = 0;

        var geometries = [
            new THREE.TorusKnotBufferGeometry(13, 3, 100, 16),
            new THREE.DodecahedronBufferGeometry(15, 0),
            new THREE.IcosahedronBufferGeometry(15, 0),
            new THREE.OctahedronBufferGeometry(15, 0),
            new THREE.TorusBufferGeometry(13, 3, 100, 16),
            new THREE.SphereBufferGeometry(15, 40, 60),
            new THREE.TubeBufferGeometry(new Curves.GrannyKnot(), 1000, 3, 10, true),
            new THREE.TubeBufferGeometry(new Curves.VivianiCurve(70), 1000, 3, 10, true),
            new THREE.TubeBufferGeometry(new Curves.CinquefoilKnot(20), 1000, 3, 10, true),
            new THREE.TubeBufferGeometry(new Curves.FigureEightPolynomialKnot(), 1000, 3, 10, true),
            // new THREE.TubeBufferGeometry(new Curves.DecoratedTorusKnot4b(), 1000, 3, 10, true),
            // new THREE.TubeBufferGeometry(new Curves.HelixCurve(), 100, 2, 5, true),
            // new THREE.TubeBufferGeometry(new Curves.DecoratedTorusKnot4a(), 1000, 3, 10, true),
            // new THREE.TubeBufferGeometry(new Curves.DecoratedTorusKnot5c(), 1000, 3, 10, true),
            // new THREE.TubeBufferGeometry(new Curves.TrefoilKnot(), 1000, 3, 10, true),
            // new THREE.TubeBufferGeometry(new Curves.GrannyKnot(), 1000, 3, 10, true),
            // [THREE.ParametricBufferGeometry, [THREE.ParametricGeometries.klein, 25, 25]]
        ], geomIndex = 0;

        var rotateCamera = true;

        function onDocumentKeyDown(event) {
            if (event.keyCode == 39) {
                event.preventDefault();
                geomIndex = (geomIndex + 1) % geometries.length;
            } else if (event.keyCode == 37) {
                event.preventDefault();
                if (geomIndex > 0) {
                    geomIndex = (geomIndex - 1) % geometries.length;
                } else {
                    geomIndex = geometries.length - 1;
                }
            }

            if (event.keyCode == 39 || event.keyCode == 37) {
                event.preventDefault();
                for (var j=0; j<floatingVids.length; j++) {
                    floatingVids[j].geometry.dispose();
                    floatingVids[j].geometry = geometries[geomIndex];
                    // floatingVids[j].material.needsUpdate = true;
                    if (geomIndex > 5) {
                        floatingVids[j].scale.set(0.5, 0.5, 0.5);
                    } else {
                        floatingVids[j].scale.set(1, 1, 1);
                    }
                }
            }

            if (event.keyCode == 32) {
                rotateCamera = !rotateCamera;
            }
        }

        function addFloatingVid(name) {
            var geometry = new THREE.TorusKnotBufferGeometry(10, 3, 100, 16);
            var mesh = new Reflector(geometry, {
                clipBias: 0.003,
                textureWidth: window.innerWidth * window.devicePixelRatio,
                textureHeight: window.innerHeight * window.devicePixelRatio,
                recursion: 1000,
                color: new THREE.Color(0.9843, 0.6549, 0)
                // color: new THREE.Color(1, 1, 0)
            } );
            mesh.getRenderTarget().texture.wrapS = THREE.MirroredRepeatWrapping;
            mesh.getRenderTarget().texture.wrapT = THREE.MirroredRepeatWrapping;
            mesh.material.needsUpdate = true;
            mesh.material.side = THREE.DoubleSide;
            // mesh.position.y = 0.5;
            // mesh.rotateX( - Math.PI / 2 );
            mesh.vidName = name;

            // mesh.vidName = name;
            return mesh;
        }

        var snds = {}, mainSnd;
        function addDomListeners() {
            window.addEventListener("resize", onResize);

            volumeButton.addEventListener('click', onVolumeChange);
            window.addEventListener("resize", onResize);
            window.addEventListener("keydown", onDocumentKeyDown);

            var goFS = document.getElementById("fullscreen");
            goFS.addEventListener("click", function() {
              document.body.requestFullscreen();
            }, false);
        }

        function getSpherePoint(point, size){
            point.x = Math.random() * 2 - 1;
            point.y = Math.random() * 2 - 1;
            point.z = Math.random() * 2 - 1;

            if(point.length() > 1) {
                return getSpherePoint(point, size);
            }
            return point.normalize().multiplyScalar(size);
        }

        //returns a Float32Array buffer of spherical 3D points
        function getSphere(count, size){
            var len = count * 4;
            var data = new Float32Array(len);
            var point = new THREE.Vector3();
            for(var i = 0; i < len; i += 4){
                getSpherePoint(point, size);
                data[i] = point.x;
                data[i + 1] = point.y;
                data[i + 2] = point.z;
                data[i + 3] = Math.abs(point.x / size);
            }
            return data;
        }

        function onResize(){
            var w = window.innerWidth;
            var h = window.innerHeight;
            renderer.setSize(w, h);
            composer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }

        var presentGaze = {};
        var morphRender = {};
        var glimpseCount = 0;
        var theGlimpse = {};
        var currentRotation = Math.PI / 180 * .3;

        var kaleidoSettings = [
            {
                // horizontal
                "sides": {value: .1},
                "angle": {value: .0},
                "uvOffset": {value: 0.},
                "diffuseOffset": {value: 0.},
            }, 
            {
                // vertical
                "sides": {value: 1.}, //> 1 diagonal w/ part; <1 diagonal w/o
                "angle": {value: .0},
                "uvOffset": {value: 0.},
                "diffuseOffset": {value: 0.},
            }, 
            {
                "sides": {value: 0.00000003}, // circles down left
                "angle": {value: .0},
                "uvOffset": {value: 0.},
                "diffuseOffset": {value: 0.},
            }, 
            {
                "sides": {value: 0.00000003},
                "angle": {value: .0},
                "uvOffset": {value: -.5},  // circles centre
                "diffuseOffset": {value: 0.},
            }, 
            {
                "sides": {value: .000003}, // trippy circle
                "angle": {value: .0},
                "uvOffset": {value: -.5},
                "diffuseOffset": {value: 0.3},
            }, 
            {
                "sides": {value: .000003},
                "angle": {value: 0.},
                "uvOffset": {value: -.5},
                "diffuseOffset": {value: .5},
                "trigoX": {value: 0}, // 0=sin, 1=cos, 2=tan, 3=atan
                "trigoY": {value: 1}
            }
        ];

        var glimpseBack = new THREE.Color(0, 0, 0), glimpseCol = new THREE.Color(1, 1, 1);
        var theFlow = [
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 5), // lots of movement
                frequency: Math.pow(10, 4), // still particles + grid lines
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: THREE.Math.randInt(3, 5),
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffsetRange: [-.5, -0.2],
                    diffuseOffsetRange: [0.1, 0.5],
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: 0.00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: 0.00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: .000003,
                    angle: 0.,
                    uvOffset: -.5,
                    diffuseOffset: .5,
                    trigoX: 0, // 0=sin, 1=cos, 2=tan, 3=atan
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: 0.00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: .00000003,
                    angle: 0.,
                    uvOffset: -.5,
                    diffuseOffset: .0,
                }
            },            
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: 0.00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 10,
                kaleido: {
                    // vertical
                    sides: 1., //> 1 diagonal w/ part; <1 diagonal w/o
                    angle: .0,
                    uvOffset: 0.,
                    diffuseOffset: 0.,
                    trigoX: 0,
                    trigoY: 1,
                }
            },
            {   // vert kaleido
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: [Math.pow(10, 2), Math.pow(10, 6)], // lots of movement
                frequency: 0.00032,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                    trigoX: 0,
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: .00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 12,
                kaleido: {
                    // horizontal
                    sides: .3,
                    angle: .0,
                    uvOffset: 0.,
                    diffuseOffset: 0.,
                    // trigoX: 0,
                    // trigoY: 1,
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: Math.pow(10, 6), // grid
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.6, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: 2.20000003,
                    angle: .0,
                    uvOffset: -.3,  // circles centre
                    diffuseOffset: 0.,
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 3), // lots of movement
                frequency: 0.5, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: 20,
                kaleido: {
                    sides: 0.00000003,
                    angle: .0,
                    uvOffsetRange: [-.3, -.7],  // circles centre - bottom-left - top-right
                    diffuseOffsetRange: [-.2, .1],
                    trigoX: 0, // 0=sin, 1=cos, 2=tan, 3=atan
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 5), // lots of movement
                frequency: Math.pow(10, 4),
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: -Math.PI / 180 * .3, // left or k-inwards
                pointSize: 3,
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 10), // lots of movement
                frequency: 0.0002,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 2.3, // left or k-inwards
                pointSize: 4,
            },
            {   // vert kaleido
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: [Math.pow(10, 1), Math.pow(10, 7)], // lots of movement
                frequency: 0.00032,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                    trigoX: 0,
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: 96, // lots of movement
                frequency: 1221,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 5,
                morph: {
                    morph: 1.0,
                    textureDest: null,
                    speed: 100.,
                },   
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                    trigoX: 0,
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: 96, // lots of movement
                frequency: 1221,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 4,
                morph: {
                    morph: 1.0,
                    textureDest: null,
                    speed: 100.,
                },   
                kaleido: {
                    sides: 2.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                    trigoX: 0,
                    trigoY: 2
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: 96, // lots of movement
                frequency: 1221,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * .03, // left or k-inwards
                pointSize: 11,
                // morph: {
                //     morph: 1.0,
                //     textureDest: null,
                //     speed: 100.,
                // },        
                kaleido: {
                    sides: 1.12002201,
                    angle: 4.2,
                    uvOffsetRange: [-.4, .2],  // circles centre
                    diffuseOffsetRange: [-.4, .4],
                }
            }
        ];

        function startAlphabet(str) {
            alphabeting = true;
            textMaterial.uniforms.timer.value = 0;
            // let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            if (typeof str == 'undefined') {
                str = "";
                for (let j = 0; j < 1; j++) {
                    str += String.fromCharCode(65+Math.floor(Math.random() * 26));
                }
            }

            textGeometry.update(str);
            // textGeometry.update(String.fromCharCode(65+Math.floor(Math.random() * 26)));
            // textGeometry.update( Math.random().toString(36).substring(2, 25) + Math.random().toString(36).substring(2, 25));

            // center the text
            textMesh.position.x = -textGeometry.layout.width / 2;
            textMesh.position.y = textGeometry.layout.height / 2 - 6;
            presentGaze.cameraPosition = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
            camera.position.set(0, 0, 30);
            renderer.setClearColor(new THREE.Color(1, 1, 1));
            FBO.particles.visible = false;
            textAnchor.visible = true;
        }

        function stopAlphabet() {
            alphabeting = false;
            camera.position.set(presentGaze.cameraPosition.x, presentGaze.cameraPosition.y, presentGaze.cameraPosition.z);
            renderer.setClearColor(new THREE.Color(0, 0, 0));
            FBO.particles.visible = true;
            textAnchor.visible = false;
        }

        var whatDoYouSeeOn = false;
        var seeingStr = ["WHAT", "DO", "YOU", "SEE?"];
        var seeingCount = 0, seeingKaleido;

        function whatDoYouSee() {
            whatDoYouSeeOn = true;
            alphabetDuration = 3;
            // var str = ["WHAT", "DO", "YOU", "SEE?"];
            // for (var j=0; j<str.length; j++) {
            //     startAlphabet(str);
            // }
            for (let j=0; j<floatingVids.length; j++)
                floatingVids[j].visible = false;

            seeingKaleido = {
                sides: 1.,
                angle: 0.,
                uvOffsetRange: [-0.7, -0.3],
                diffuseOffsetRange: [0.4, 0.6],
                // trigoX: 0,
                // trigoY: 1
            }
        }

        function startGlimpse() {
            glimpsing = true;
            glimpseCount += 1;

            savePresentGaze();
            theGlimpse = theFlow[THREE.Math.randInt(0, theFlow.length - 1)];

            if ('kaleido' in theGlimpse) {
                startKaleido();
            }
            if ('morph' in theGlimpse) {
                startMorph(
                    theGlimpse.morph.textureDest,
                    theGlimpse.morph.speed,
                    theGlimpse.morph.pointSize
                )
            }

            if (Array.isArray(theGlimpse.amplitude)) {
                simulationShader.uniforms.amplitude.value = THREE.Math.randFloat(theGlimpse.amplitude[0], theGlimpse.amplitude[1]);
            } else {
                simulationShader.uniforms.amplitude.value = theGlimpse.amplitude;
            }
            simulationShader.uniforms.frequency.value = THREE.Math.randFloat(theGlimpse.frequency / 3, theGlimpse.frequency * 3);
            renderShader.uniforms.pointSize.value = theGlimpse.pointSize;
            // var cc = [theGlimpse.particlesColor, particleColor];
            renderShader.uniforms.nColor.value = theGlimpse.particlesColor; //cc[THREE.Math.randInt(0, 1)];
            glimpseBackColor = theGlimpse.backgroundColor;
            currentRotation = theGlimpse.particlesRotationY;

            renderer.setClearColor(glimpseBackColor);
            // playSound(theGlimpse.sound);
        }

        function stopGlimpse() {
            kaleidoing = false;
            glimpsing = false;
            // soundObj.pause();
            bringBackPresentGaze();

            if ('morph' in theGlimpse) {
                stopMorph();
            }

            renderer.setClearColor(backColor);
        }

        function startTrip(name) {
            glimpseOn = true;
            alphabetOn = true;
            scheduleVideo(name, 8);

            sndNameToStop = playSound('transition', 0.3, 1);

            for (var j=0; j<floatingVids.length; j++) {
                sky.remove(floatingVids[j]);
            }

            simulationShader.uniforms.amplitude.value += 10;
            // timer = 200;
            document.body.style.cursor = "url('css/chaos-magick.png'), auto";
            renderShader.uniforms.nColor.value = new THREE.Color(0, 0, 0);
            backColor = new THREE.Color(1, 1, 1);
            renderer.setClearColor(backColor);
        }

        function startKaleido(params) {
            kaleidoing = true;
            params = params || theGlimpse.kaleido;

            kaleidoscopePass.material.uniforms.sides.value = params.sides;

            if (Array.isArray(params.angle))
                kaleidoscopePass.material.uniforms.angle.value = THREE.Math.randFloat(params.angle[0], params.angle[1]);
            else {
                kaleidoscopePass.material.uniforms.angle.value = params.angle;
            }

            if ('uvOffset' in params) {
                kaleidoscopePass.material.uniforms.uvOffset.value = params.uvOffset;
            } else if ('uvOffsetRange' in params) {
                kaleidoscopePass.material.uniforms.uvOffset.value = THREE.Math.randFloat(params.uvOffsetRange[0], params.uvOffsetRange[1]);
            }

            if ('diffuseOffset' in params) {
                kaleidoscopePass.material.uniforms.diffuseOffset.value = params.diffuseOffset;
            } else if ('diffuseOffsetRange' in params) {
                kaleidoscopePass.material.uniforms.diffuseOffset.value = THREE.Math.randFloat(params.diffuseOffsetRange[0], params.diffuseOffsetRange[1]);
            }
            kaleidoscopePass.material.uniforms.trigoX.value = params.trigoX !== undefined ? params.trigoX : THREE.Math.randInt(0, 3);
            kaleidoscopePass.material.uniforms.trigoY.value = params.trigoY !== undefined ? params.trigoY : THREE.Math.randInt(0, 3);

            kaleidoscopePass.material.needsUpdate = true;
            // kaleidoscopePass.enabled = true;
        }

        function startMorph(textureDest, speed, pointSize) {
            simulationShader.uniforms.morph.value = 1.0;
            simulationShader.uniforms.textureDest.value = textureDest || getRandImgTexture();
            simulationShader.uniforms.morphTimestamp.value = timer;
            simulationShader.uniforms.morphSpeed.value = speed || 0.8;
            renderShader.uniforms.pointSize.value = pointSize || 4;
            camera.position.set(0., 200., 5.);
        }

        function stopMorph() {
            simulationShader.uniforms.morph.value = 0.0;
        }

        function savePresentGaze() {
            presentGaze.amplitude = simulationShader.uniforms.amplitude.value;
            presentGaze.frequency = simulationShader.uniforms.frequency.value;
            presentGaze.texture = simulationShader.uniforms.texture.value;
            presentGaze.pointSize = renderShader.uniforms.pointSize.value;
            presentGaze.renderColor = renderShader.uniforms.nColor.value;
            presentGaze.backgroundColor = backColor;
            presentGaze.currentRotation = currentRotation;
            presentGaze.cameraPosition = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
            // debugger;
        }

        function bringBackPresentGaze() {
            simulationShader.uniforms.amplitude.value = presentGaze.amplitude;
            simulationShader.uniforms.frequency.value = presentGaze.frequency;
            simulationShader.uniforms.texture.value = presentGaze.texture;
            renderShader.uniforms.pointSize.value = presentGaze.pointSize;
            renderShader.uniforms.nColor.value = presentGaze.renderColor;
            backColor = presentGaze.backgroundColor;
            currentRotation = presentGaze.currentRotation;
            camera.position.set(presentGaze.cameraPosition.x, presentGaze.cameraPosition.y, presentGaze.cameraPosition.z);
        }

        var defaultBackColor=new THREE.Color(0, 0, 0.02), backColor=new THREE.Color(0, 0, 0.02), glimpseBackColor=new THREE.Color(1, 1, 1);
        var defaultParticleColor=new THREE.Color(1, 1, 1), particleColor=new THREE.Color(1, 1, 1), stroboParticleColor=new THREE.Color(0, 0, 0);

        function stroboBackground() {
            let tempBack = glimpseBackColor;
            glimpseBackColor = backColor;
            backColor = tempBack;
            renderer.setClearColor(backColor);
            // let tempParticle = stroboParticleColor;
            // stroboParticleColor = particleColor;
            // particleColor = tempParticle;
            // renderShader.uniforms.nColor.value = particleColor;
        }

        var nextVideo, nextVideoCountdown = 0;

        function scheduleVideo(name, time) {
            nextVideo = name;
            nextVideoCountdown = time;
        }

        function playVideo(name) {
            hyperspace(name, renderer, scene);
            delayGlimpseStop(4);
        }

        var glimpseTimer = 0, sndNameToStop;
        function delayGlimpseStop(time) {
            glimpseTimer = time;
            playSound('video', 2, -1);
        }

        function hyperspace(name, renderer, scene) {
            hyperspaceOn = true;
            hyperspacing = true;
            var loader = new THREE.TextureLoader();
            loader.crossOrigin = "Anonymous";
            // theGlimpse.length *= 3;
            loader.load(
                "vid/" + name + ".jpeg",
                function(texture) {
                    window.tunnel = new Tunnel(texture, renderer, scene);
                    window.tunnel.vidName = name;
                }
            );
        }

        var glimpseOn = false, alphabetOn = false;
        var stroboHyper = true;
        var hyperspaceOn = false, hyperspacing = false;

        function stopHyperspace() {
            hyperspaceOn = false;
            hyperspacing = false;
            scene.remove(window.tunnel.tubeMesh);
            window.tunnel.stop();

            if (glimpsing)
                stopGlimpse();

            // Queue video
            snds[sndNameToStop].pause();
            currVid = vid360.init(renderer, vids[window.tunnel.vidName], Curves, playSound);
            currVid.start();
            videoPlaying = true;
        }

        var seeingStr = ["WHAT", "DO", "YOU", "SEE?"];
        var seeingCount = 0;

        function update() { 
            requestAnimationFrame(update);

            timer += timerInc;
            let timerInt = parseInt(timer);

            simulationShader.uniforms.timer.value = timer;
            renderShader.uniforms.timer.value = timer;

            if (whatDoYouSeeOn) {
                // if (timerInt % 4 == 0)
                seeingCount = parseInt((timerInt % 8)/2);

                var alaphabetInterval = THREE.Math.randInt(2, 4);
                if (!alphabeting && timerInt % alaphabetInterval == 0) {
                    startKaleido(seeingKaleido);
                    startAlphabet(seeingStr[seeingCount]);
                    renderer.setClearColor(new THREE.Color(0, 0, 0));
                    textMaterial.uniforms.color.value = new THREE.Color(1, 1, 1);
                } else if (alphabeting && timer % alaphabetInterval > 1) {
                    stopAlphabet();
                    kaleidoing = false;
                    renderer.setClearColor(new THREE.Color(0, 0, 0));
                }
                textMaterial.uniforms.timer.value += timerInc;
                if (textMaterial.uniforms.timer.value > alphabetDuration) {
                    textMaterial.uniforms.timer.value = 0;
                }

                if (timerInt % 3 == 0)
                    composer.render();
                else 
                    renderer.render(scene, camera);
                return;
            }

            if (glimpseTimer > 0) {
                glimpseTimer -= timerInc;
                if (glimpseTimer <= 0) {
                    glimpseOn = false;
                    alphabetOn = false;
                    hyperspacing = true;
                }
            }

            if (videoPlaying) {
                currVid.update(-0.1);
                if (!currVid.playing) {
                    videoPlaying = false;
                    playSound('sky', 0.5, 3);
                    lastVideo = currVid.name;

                    if (glimpsing)
                        stopGlimpse();
                    if (alphabeting)
                        stopAlphabet();

                    // simulationShader.uniforms.amplitude.value = 100;
                    // timer = 200;
                    document.body.style.cursor = "url('css/chaos-magick.png'), auto";
                    renderShader.uniforms.nColor.value = new THREE.Color(1, 1, 1);
                    backColor = new THREE.Color(0, 0, 0);
                    renderer.setClearColor(backColor);

                    for (let j=0; j<floatingVids.length; j++) {
                        if ("vid/" + floatingVids[j].vidName + '.webm' == lastVideo) {
                            floatingVids.splice(j, 1);
                        } 
                    }

                    if (vidCount == 4) {
                        vidCount = 0;
                        remainingVids = ['barber', 'thornhill2', 'wasserturm1', 'bus', 'petrol', 'wasserturm2', 'thornhill1'];
                    }
                    if (floatingVids.length == 1)
                        floatingVids.push(addFloatingVid(remainingVids[vidCount]));

                    for (let j=0; j<floatingVids.length; j++) {
                        floatingVids[j].position.set(
                            THREE.Math.randInt(-90, 90),
                            THREE.Math.randInt(-90, 90),
                            THREE.Math.randInt(-70, 70)
                        );
                        sky.add(floatingVids[j]);
                    }
                    vidCount += 1;
                }
                if (!glimpseOn)
                    return;
            }

            if (hyperspaceOn) {
                if (typeof window.tunnel !== undefined) {
                    if (window.tunnel.progress() > 0.99) {
                        stopHyperspace();
                        return;
                    }
                }
                if (glimpseOn) {
                    var hyperspaceInterval = THREE.Math.randInt(2, 9);
                    if (!hyperspacing && timerInt % hyperspaceInterval == 0) {
                        hyperspacing = true;
                    } else if (hyperspacing && timer % hyperspaceInterval > 1) {
                        hyperspacing = false;
                    }
                }
                if (hyperspacing) {
                    window.tunnel.render();
                    return;
                }
            }

            if (nextVideoCountdown > 0) {
                nextVideoCountdown -= timerInc;
                if (nextVideoCountdown <= 0) {
                    if (!videoPlaying) {
                        playVideo(nextVideo);
                    }
                }
            }

            //update simulation
            FBO.update();

            if (glimpseOn) {
                // Pick a time interval for how often to start the glimpse effect
                var glimpseInterval = THREE.Math.randInt(1, 9);
                if (timerInt % glimpseInterval == 0) {
                    if (!glimpsing) {
                        startGlimpse();
                    }
                } else if (glimpsing && timer % glimpseInterval > theGlimpse.length * 5) {
                    stopGlimpse();
                }
            }

            if (alphabetOn) {
                var alaphabetInterval = THREE.Math.randInt(2, 9);
                if (!alphabeting && timerInt % alaphabetInterval == 0) {
                    startAlphabet();
                } else if (alphabeting && timer % alaphabetInterval > 3) {
                    stopAlphabet();
                }
                if (alphabeting) {
                    textMaterial.uniforms.timer.value += timerInc;
                    if (textMaterial.uniforms.timer.value > alphabetDuration) {
                        textMaterial.uniforms.timer.value = 0;
                        alphabeting = false;
                    }
                }

            }

            // Constant counter-clockwise rotation, dervish style
            // FBO.particles.rotation.y -= currentRotation;

            // camera.position.x -= 10 * Math.PI / 180;
            if (rotateCamera)
                sky.rotation.y -= currentRotation;

            controls.update();

            for (let j=0; j<floatingVids.length; j++) {
                floatingVids[j].lookAt(camera.position);
            }

            // If we are in glimpse mode
            // Also check if the kaleido effect is on and call the effect composer
            if (glimpsing) {
                if (theGlimpse.stroboBackground) {
                    stroboBackground();
                }
            } else {
                // When we reach min/max sphere amplitude, reverse
                if (simulationShader.uniforms.amplitude.value < 50 || simulationShader.uniforms.amplitude.value > 175) {
                    amplDec = -amplDec;
                    amplInc = -amplInc;
                }
            }

            if (kaleidoing) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
            // renderer.render(sceneCube, cameraCube);
            renderer.autoClear = false;

            // Increase or decrease the amplitutde cyclically every time unit
            if (timerInt % 2 == 0) {
                simulationShader.uniforms.amplitude.value += amplInc;
            } else if (timerInt % 2 == 1) {
                simulationShader.uniforms.amplitude.value -= amplDec;
            }
        }

        //returns a Float32Array buffer of 3D points after an image
        function getImage(img, elevation){
            var ctx = getContext(null, img.width, img.height);
            ctx.drawImage(img, 0, 0);
            var imgData = ctx.getImageData(0, 0, img.width, img.height);
            var iData = imgData.data;

            var l = (img.width * img.height);
            var data = new Float32Array(l * 3);
            for (var i = 0; i < l; i++) {
                var i3 = i * 3;
                var i4 = i * 4;
                data[i3] = (i % img.width) - img.width * .5;
                data[i3 + 1] = (iData[i4] / 0xFF * 0.299 +iData[i4+1]/0xFF * 0.587 + iData[i4+2] / 0xFF * 0.114) * elevation;
                data[i3 + 2] = (parseInt(i / img.width) - img.height * .5);
            }
            return data;
        }
        function getCanvas(w, h){
            var canvas = document.createElement("canvas");
            canvas.width = w || 512;
            canvas.height = h || 512;
            return canvas;
        }
        function getContext(canvas, w, h){
            canvas = canvas || getCanvas(w, h);
            canvas.width = w || canvas.width;
            canvas.height = h || canvas.height;
            return canvas.getContext("2d");
        }

        function getRandImgTexture() {
            let img = imgs[THREE.Math.randInt(0, imgs.length - 1)];
            let data = getImage(img, 64);
            let texture = new THREE.DataTexture(data, img.width, img.height, THREE.RGBFormat, THREE.FloatType);
            texture.needsUpdate = true;
            return texture;
        }

        document.addEventListener('mousemove', onDocumentMouseMove, false);

        var mouse = new THREE.Vector2();
        var raycaster = new THREE.Raycaster();

        function onDocumentMouseMove(event) {
            if (videoPlaying) {
                document.body.style.cursor = "url('css/chaos-magick.png'), auto";
                return;
            }

            var mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(floatingVids);
            if (intersects.length) {
                document.body.style.cursor = "pointer";
            } else {
                document.body.style.cursor = "url('css/chaos-magick.png'), auto";
            }
        }

        document.addEventListener('mousedown', onMouseDown, false);
        function onMouseDown(event) {
            if (videoPlaying) {
                document.body.style.cursor = "url('css/chaos-magick.png'), auto";
                return;
            }
            event.preventDefault();

            var mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(floatingVids);
            if (intersects.length) {
                startTrip(intersects[0].object.vidName);
            }
        }

        async function loadImages(imageUrlArray) {
            const promiseArray = [];
            const imageArray = [];

            for (let imageUrl of imageUrlArray) {
                promiseArray.push(new Promise(resolve => {
                    const img = new Image();
                    img.onload = resolve;
                    img.src = 'img/' + imageUrl;
                    imageArray.push(img);
                }));
            }

            await Promise.all(promiseArray);
            return imageArray;
        }

    </script>
</body>
</html>