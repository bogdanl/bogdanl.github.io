<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>mirrorsin.space</title>
    <!-- <link href="css/main.css" rel="stylesheet"> -->
    <style>
        head, body{
    width:100%;
    height:100%;
    overflow: hidden;
    top:0;
    left:0;
    margin:0;
    padding:0;
    cursor: url('css/chaos-magick.png'), auto;
    font-family: optima;
    color: white;
    text-align: justify;
}
#title {
    position: absolute;
    left: 10px;
    bottom: 10px;
    cursor: url('css/chaos-magick.png'), auto;
    width: 330px;
    text-align: justify;
    text-align-last: justify;
    text-justify: inter-word;
}
#instructions {
    position: absolute;
    font-family: optima;
    right: 10px;
    bottom: 10px;
    width: 280px;
    text-align: justify;
    text-align-last: justify;
    text-justify: inter-word;
    text-transform: uppercase;
}
#volume {
    position: absolute;
    top: 3px;
    left: 3px;
    font-size: 13px;
    font-style: bold;
    cursor: pointer;
}
#fullscreen {
    position: absolute;
    top: 3px;
    right: 3px;
    cursor: pointer;
}
</style>
</head>
<body>
    <div id="fullscreen">fullscreen</div>
    <div id="title">
        <strong>mirrors in space â˜· coming soon</strong> to be outlived<br>
        by the stairs free falling into the running water<br>
        the stars rolling away from each other<br>
        outshone by silhouettes on fortuitous placards<br>
        & out of sight; forgetful of its smeared desires
    </div>
    <div id="instructions">
        <strong>you can use the trackpad<br> to move around, zoom & click</strong>
    </div>
    <div id="volume">TURN SOUND ON</div>

    <div id="container"></div>

    <script src="vendor/three.min.js"></script>
    <script src="vendor/OrbitControls.js"></script>
    <script src="ShaderLoader.js"></script>
    <script src="fbo.js"></script>
    <script src="vid360.js"></script>
    <script src="vendor/three-bmfont.js"></script>
    <script src="vendor/load-bmfont.js"></script>
    <script src="vendor/TweenMax.min.js"></script>
    <script src="hyperspace.js"></script>

    <script type="module">
        import {EffectComposer} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/EffectComposer.js';
        import {RenderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/RenderPass.js';
        import {ShaderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/ShaderPass.js';
        import {Curves} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/curves/CurveExtras.js';

        var scene, camera, renderer, composer, controls, timer=0, timerInc=.01;
        var simulationShader, renderShader, kaleidoscopePass;
        var soundOn=false, audioLoader, soundObj;

        var glimpsing = false, glimpseLength = 1, amplInc = 0.11, amplDec = 0.08;
        var texture, video, videoMaterial, defaultTexture;
        var imgUrls = ['ourobouros.jpeg', 'ourobouros2.jpeg', 'sigil.jpeg', 'astro.jpeg', 'focus.jpeg', 'solar.jpeg']
        var imgs = [];
        var videoPlaying = false, kaleidoing = false;
        var listener, volumeButton;

        var textMaterial, textGeometry, textMesh, textAnchor, font, fontTexture, alphabeting, alphabetDuration = 0.5;

        var vids = {
            thornhill1: 'https://content.jwplatform.com/videos/uyV9eWMN-ac7wx05Q.mp4',
            thornhill2: 'https://content.jwplatform.com/videos/pefTTpeR-yhiBISfO.mp4'
            // thornhill1: 'vid/thornhill1.webm',
            // thornhill2: 'vid/thornhill2.webm',
        };

        window.onload = function() {
            var sl = new ShaderLoader();
            sl.loadShaders({
                noise_simulationVS : "",
                noise_simulationFS : "",
                noise_renderVS : "",
                noise_renderFS : "",                
                bmfont_frag : "",
                bmfont_vert : "",
            }, "./glsl/", init );
        };

        function playSound(name, crossFade) {
            if (audioLoader == undefined) {
                audioLoader = new THREE.AudioLoader();
                listener = new THREE.AudioListener();
                camera.add(listener);
            }

            let snd = new THREE.Audio(listener);

            crossFade = crossFade || false;
            if (crossFade) {
                var volume = {x : 1};

                TweenMax.to(volume, 3, {
                    x: 0,
                    onUpdate: function() {
                        for (const [sndName, snd] of Object.entries(snds)) {
                            if (sndName !== name)
                                snd.setVolume(this.target.x);
                        }
                    },
                    onComplete: function() {
                        for (const [sndName, snd] of Object.entries(snds)) {
                            if (sndName !== name)
                                snd.pause();
                        }
                    },
                });
            }

            audioLoader.load('snd/' + name + '.ogg', function(buffer) {
                snd.setBuffer(buffer);
                snd.setLoop(true);
                snd.setVolume(0.8);
                if (soundOn) {
                    snd.play();
                }
                snds[name] = snd;
            });
        }

        function onVolumeChange(event) {
            if (!soundOn) {
                soundOn = true;
                for (const [name, snd] of Object.entries(snds)) {
                    snd.play();
                }
                volumeButton.innerHTML = "TURN SOUND OFF";
            } else {
                for (const [name, snd] of Object.entries(snds)) {
                    snd.pause();
                }
                volumeButton.innerHTML = "TURN SOUND ON";
                soundOn = false;
            }
        }

        //returns a Float32Array buffer of random 3D coordinates
        function getRandomData(count, size){
            var len = count * 4;
            var data = new Float32Array(len);
            while(len--) {
                data[len] = (Math.random() - .5) * size;
            }
            return data;
        }

        function getDefaultTexture(width, height, size) {
            let data = getSphere(width * height, size);
            let texture = new THREE.DataTexture(
                data, width, height, THREE.RGBAFormat, THREE.FloatType, THREE.DEFAULT_MAPPING, THREE.MirroredRepeatWrapping, THREE.MirroredRepeatWrapping
                );
            texture.needsUpdate = true;
            return texture;
        }

        function init(args) {
            loadImages(imgUrls).then(images => {
                imgs = images;
                loadFont('fonts/DejaVu-sdf.fnt', function(err, fnt) {
                    font = fnt;
                    let textureLoader = new THREE.TextureLoader();
                    textureLoader.load('fonts/DejaVu-sdf.png', function (texture) {
                        fontTexture = texture;
                        initCont(args);
                    });
                });
            });
        }

        function initCont(args) {
            args = args || {};
            var w = window.innerWidth;
            var h = window.innerHeight;
            renderer = new THREE.WebGLRenderer({
                logarithmicDepthBuffer: true,
                antialias: true
            });
            renderer.setSize(w, h);
            renderer.setClearColor(defaultBackColor);

            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(100, 0, 0.0001, 10000000);

            controls = new THREE.OrbitControls(camera);
            camera.position.z = 30;
            controls.enableDamping = true;
            // controls.maxDistance = 1000000;
            // controls.minDistance = 30;

            // create an AudioListener and add it to the camera
            volumeButton = document.getElementById('volume');

            var ww = 512;
            var width  = args.w || ww;
            var height = args.h || ww;

            // create a geometry of packed bitmap glyphs, 
            // word wrapped to 300px and right-aligned
            textGeometry = bmfont({
                width: 100,
                align: 'center',
                font: font,
                // flipY: true
            });
            // the texture atlas containing our glyphs
            textMaterial = new THREE.RawShaderMaterial({
                vertexShader: ShaderLoader.get("bmfont_vert"),
                fragmentShader: ShaderLoader.get("bmfont_frag"),
                uniforms: {
                    animate: {type: 'f', value: 1.},
                    duration: {type: 'f', value: alphabetDuration},
                    timer: {type: 'f', value: 0.},
                    map: {type: 't', value: fontTexture},
                    color: {type: 'c', value: new THREE.Color(0, 0, 0)}
                },
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false
            });
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            // scale it down so it fits in our 3D units
            textAnchor = new THREE.Object3D();
            // textAnchor.scale.multiplyScalar(-0.005);
            textAnchor.add(textMesh);
            textAnchor.rotation.x = Math.PI;
            scene.add(textAnchor);

            defaultTexture = getDefaultTexture(width, height, args.s || 2000);

            simulationShader = new THREE.ShaderMaterial({
                uniforms: {
                    texture: {type: "t", value: defaultTexture},
                    timer: {type: "f", value: 0},
                    frequency: {type: "f", value: .00032},
                    amplitude: {type: "f", value: 45},
                    maxDistance: {type: "f", value: 40},
                    morph: {type: 'f', value: 0.0},
                    textureDest: {type: "t", value: null},
                    morphTimestamp: {type: 'f', value: null},
                    morphSpeed: {type: 'f', value: 0.1},
                    mouse: {type: "v3", value: new THREE.Vector3(0)},
                    // alphaMap: { type: 't', value: currVid.mesh.material.alphaMap }
                },
                vertexShader: ShaderLoader.get( "noise_simulationVS"),
                fragmentShader:  ShaderLoader.get( "noise_simulationFS"),
            });

            renderShader = new THREE.ShaderMaterial( {
                uniforms: {
                    positions: {type: "t", value: null},
                    pointSize: {type: "f", value: 3},
                    nColor: {type: "v3", value: new THREE.Vector3(1, 1, 1)},
                    big: {type: "v3", value: new THREE.Vector3(207, 221, 212).multiplyScalar(1/0xFF)},
                    small: {type: "v3", value: new THREE.Vector3(213, 239, 229).multiplyScalar(1/0xFF)},
                    timer: {value: timer},
                    mouse: {type: "v3", value: new THREE.Vector3(0)}
                },
                vertexShader: ShaderLoader.get("noise_renderVS"),
                fragmentShader: ShaderLoader.get("noise_renderFS"),
                transparent: true,
                side:THREE.DoubleSide,
            });

            const kaleidoscopeShader = {
                uniforms: {
                  "tDiffuse": {value: null},
                  "sides": {value: 1.},
                  "angle": {value: 0.},
                  "uvOffset": {value: -.5},
                  "diffuseOffset": {value: .5},
                  // 0=sin, 1=cos, 2=tan, 3=atan
                  "trigoX": {value: 0},
                  "trigoY": {value: 1}
                },
                vertexShader: `
                    varying vec2 vUv;

                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float sides;
                    uniform float angle;
                    uniform float uvOffset;
                    uniform float diffuseOffset;
                    uniform int trigoX;
                    uniform int trigoY;

                    varying vec2 vUv;
                    const float tau = 2. * 3.1415926535897932384626433832795;

                    float _trigo(int trigo, float a) {
                        if (trigo == 0)
                            return sin(a);
                        if (trigo == 1)
                            return cos(a);
                        if (trigo == 2)
                            return tan(a);
                        if (trigo == 3)
                            return atan(a);
                    }

                    void main() {
                        vec2 p = vUv + uvOffset;
                        float r = length(p);
                        float a = atan(p.x, p.y) + angle;
                        a = mod(a, tau/sides);
                        a = abs(a - tau/sides/2.);
                        p = r * vec2(_trigo(trigoX, a), _trigo(trigoY, a));
                        vec4 color = texture2D(tDiffuse, p + diffuseOffset);
                        gl_FragColor = color;
                    }
                `
              };

            FBO.init(width, height, renderer, simulationShader, renderShader);

            addDomListeners();

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            kaleidoscopePass = new ShaderPass(kaleidoscopeShader);
            kaleidoscopePass.renderToScreen = true;
            // kaleidoscopePass.enabled = true;
            composer.addPass(kaleidoscopePass);

            currVid = vid360.init(renderer, vids['thornhill2'], Curves, playSound);
            currVid.start();
            videoPlaying = true;
            mainSnd = 'thornhill2';
            playSound(mainSnd);

            sky = new THREE.Group();
            sky.add(FBO.particles);

            floatingVids.push(addFloatingVid('thornhill1'));
            floatingVids.push(addFloatingVid('thornhill2'));

            for (let j=0; j<floatingVids.length; j++) {
                sky.add(floatingVids[j]);
                floatingVids[j].position.set(
                    THREE.Math.randInt(-70, -30),
                    THREE.Math.randInt(-30, 70),
                    THREE.Math.randInt(-40, 40)
                );
            }
            scene.add(sky);

            onResize();
            update();
        }

        var floatingVids = [], currVid, sky;

        function addFloatingVid(name) {
            // vid.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
            // vid.camera.target = new THREE.Vector3(0, 0, 0);
            // vid.scene = new THREE.Scene();
            // vid.raycaster = new THREE.Raycaster();

            var geometry = new THREE.TorusKnotBufferGeometry(10, 3, 100, 16);
            // geometry.scale(-1, 1, 1);
            var material = new THREE.MeshBasicMaterial(
                {map: new THREE.TextureLoader().load("vid/" + name + ".png")}
            );
            var mesh = new THREE.Mesh(geometry, material);
            mesh.vidName = name;
            return mesh;
        }

        var snds = {}, mainSnd;
        function addDomListeners() {
            window.addEventListener("resize", onResize);

            volumeButton.addEventListener('click', onVolumeChange);
            window.addEventListener("resize", onResize);

            var goFS = document.getElementById("fullscreen");
            goFS.addEventListener("click", function() {
              document.body.requestFullscreen();
            }, false);
        }

        function getSpherePoint(point, size){
            point.x = Math.random() * 2 - 1;
            point.y = Math.random() * 2 - 1;
            point.z = Math.random() * 2 - 1;

            if(point.length() > 1) {
                return getSpherePoint(point, size);
            }
            return point.normalize().multiplyScalar(size);
        }

        //returns a Float32Array buffer of spherical 3D points
        function getSphere(count, size){
            var len = count * 4;
            var data = new Float32Array(len);
            var point = new THREE.Vector3();
            for(var i = 0; i < len; i += 4){
                getSpherePoint(point, size);
                data[i] = point.x;
                data[i + 1] = point.y;
                data[i + 2] = point.z;
                data[i + 3] = Math.abs(point.x / size);
            }
            return data;
        }

        function onResize(){
            var w = window.innerWidth;
            var h = window.innerHeight;
            renderer.setSize(w, h);
            composer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }

        var presentGaze = {};
        var morphRender = {};
        var glimpseCount = 0;
        var theGlimpse = {};
        var currentRotation = Math.PI / 180 * .3;

        var kaleidoSettings = [
            {
                // horizontal
                "sides": {value: .1},
                "angle": {value: .0},
                "uvOffset": {value: 0.},
                "diffuseOffset": {value: 0.},
            }, 
            {
                // vertical
                "sides": {value: 1.}, //> 1 diagonal w/ part; <1 diagonal w/o
                "angle": {value: .0},
                "uvOffset": {value: 0.},
                "diffuseOffset": {value: 0.},
            }, 
            {
                "sides": {value: 0.00000003}, // circles down left
                "angle": {value: .0},
                "uvOffset": {value: 0.},
                "diffuseOffset": {value: 0.},
            }, 
            {
                "sides": {value: 0.00000003},
                "angle": {value: .0},
                "uvOffset": {value: -.5},  // circles centre
                "diffuseOffset": {value: 0.},
            }, 
            {
                "sides": {value: .000003}, // trippy circle
                "angle": {value: .0},
                "uvOffset": {value: -.5},
                "diffuseOffset": {value: 0.3},
            }, 
            {
                "sides": {value: .000003},
                "angle": {value: 0.},
                "uvOffset": {value: -.5},
                "diffuseOffset": {value: .5},
                "trigoX": {value: 0}, // 0=sin, 1=cos, 2=tan, 3=atan
                "trigoY": {value: 1}
            }
        ];

        var glimpseBack = new THREE.Color(0, 0, 0), glimpseCol = new THREE.Color(1, 1, 1);
        var theFlow = [
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 5), // lots of movement
                frequency: Math.pow(10, 4), // still particles + grid lines
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: THREE.Math.randInt(3, 5),
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffsetRange: [-.5, -0.2],
                    diffuseOffsetRange: [0.1, 0.5],
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: 0.00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: 0.00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: .000003,
                    angle: 0.,
                    uvOffset: -.5,
                    diffuseOffset: .5,
                    trigoX: 0, // 0=sin, 1=cos, 2=tan, 3=atan
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: 0.00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: .00000003,
                    angle: 0.,
                    uvOffset: -.5,
                    diffuseOffset: .0,
                }
            },            
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: 0.00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 10,
                kaleido: {
                    // vertical
                    sides: 1., //> 1 diagonal w/ part; <1 diagonal w/o
                    angle: .0,
                    uvOffset: 0.,
                    diffuseOffset: 0.,
                    trigoX: 0,
                    trigoY: 1,
                }
            },
            {   // vert kaleido
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: [Math.pow(10, 2), Math.pow(10, 6)], // lots of movement
                frequency: 0.00032,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                    trigoX: 0,
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: .00032, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 12,
                kaleido: {
                    // horizontal
                    sides: .3,
                    angle: .0,
                    uvOffset: 0.,
                    diffuseOffset: 0.,
                    // trigoX: 0,
                    // trigoY: 1,
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 6), // lots of movement
                frequency: Math.pow(10, 6), // grid
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.6, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: 2.20000003,
                    angle: .0,
                    uvOffset: -.3,  // circles centre
                    diffuseOffset: 0.,
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 3), // lots of movement
                frequency: 0.5, // movement
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: 20,
                kaleido: {
                    sides: 0.00000003,
                    angle: .0,
                    uvOffsetRange: [-.3, -.7],  // circles centre - bottom-left - top-right
                    diffuseOffsetRange: [-.2, .1],
                    trigoX: 0, // 0=sin, 1=cos, 2=tan, 3=atan
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 5), // lots of movement
                frequency: Math.pow(10, 4),
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: -Math.PI / 180 * .3, // left or k-inwards
                pointSize: 3,
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: Math.pow(10, 10), // lots of movement
                frequency: 0.0002,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 2.3, // left or k-inwards
                pointSize: 4,
            },
            {   // vert kaleido
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: [Math.pow(10, 1), Math.pow(10, 7)], // lots of movement
                frequency: 0.00032,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 4,
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                    trigoX: 0,
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: 96, // lots of movement
                frequency: 1221,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 5,
                morph: {
                    morph: 1.0,
                    textureDest: null,
                    speed: 100.,
                },   
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                    trigoX: 0,
                    trigoY: 1
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: 96, // lots of movement
                frequency: 1221,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * 0.3, // left or k-inwards
                pointSize: 4,
                morph: {
                    morph: 1.0,
                    textureDest: null,
                    speed: 100.,
                },   
                kaleido: {
                    sides: 2.,
                    angle: 0.,
                    uvOffset: -0.5,
                    diffuseOffset: 0.5,
                    trigoX: 0,
                    trigoY: 2
                }
            },
            {
                length: 1,
                stroboBackground: false,
                sound: 'tempo-change',
                amplitude: 96, // lots of movement
                frequency: 1221,
                particlesColor: glimpseCol,
                backgroundColor: glimpseBack,
                particlesRotationY: Math.PI / 180 * .03, // left or k-inwards
                pointSize: 11,
                // morph: {
                //     morph: 1.0,
                //     textureDest: null,
                //     speed: 100.,
                // },        
                kaleido: {
                    sides: 1.12002201,
                    angle: 4.2,
                    uvOffsetRange: [-.4, .2],  // circles centre
                    diffuseOffsetRange: [-.4, .4],
                }
            }
        ];

        function startAlphabet() {
            alphabeting = true;
            textMaterial.uniforms.timer.value = 0;
            // let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let rndStr = "";
            for (let j = 0; j < 1; j++) {
                rndStr += String.fromCharCode(65+Math.floor(Math.random() * 26));
            }
            textGeometry.update(rndStr);
            // textGeometry.update(String.fromCharCode(65+Math.floor(Math.random() * 26)));
            // textGeometry.update( Math.random().toString(36).substring(2, 25) + Math.random().toString(36).substring(2, 25));

            // center the text
            textMesh.position.x = -textGeometry.layout.width / 2;
            textMesh.position.y = textGeometry.layout.height / 2 - 6;
            presentGaze.cameraPosition = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
            camera.position.set(0, 0, 30);
            renderer.setClearColor(new THREE.Color(1, 1, 1));
            FBO.particles.visible = false;
            textAnchor.visible = true;
        }

        function stopAlphabet() {
            alphabeting = false;
            camera.position.set(presentGaze.cameraPosition.x, presentGaze.cameraPosition.y, presentGaze.cameraPosition.z);
            renderer.setClearColor(new THREE.Color(0, 0, 0));
            FBO.particles.visible = true;
            textAnchor.visible = false;
        }

        function startGlimpse() {
            glimpsing = true;
            glimpseCount += 1;

            savePresentGaze();
            theGlimpse = theFlow[THREE.Math.randInt(0, theFlow.length - 1)];

            if ('kaleido' in theGlimpse) {
                startKaleido();
            }
            if ('morph' in theGlimpse) {
                startMorph(
                    theGlimpse.morph.textureDest,
                    theGlimpse.morph.speed,
                    theGlimpse.morph.pointSize
                )
            }

            if (Array.isArray(theGlimpse.amplitude)) {
                simulationShader.uniforms.amplitude.value = THREE.Math.randFloat(theGlimpse.amplitude[0], theGlimpse.amplitude[1]);
            } else {
                simulationShader.uniforms.amplitude.value = theGlimpse.amplitude;
            }
            simulationShader.uniforms.frequency.value = THREE.Math.randFloat(theGlimpse.frequency / 3, theGlimpse.frequency * 3);
            renderShader.uniforms.pointSize.value = theGlimpse.pointSize;
            // var cc = [theGlimpse.particlesColor, particleColor];
            renderShader.uniforms.nColor.value = theGlimpse.particlesColor; //cc[THREE.Math.randInt(0, 1)];
            glimpseBackColor = theGlimpse.backgroundColor;
            currentRotation = theGlimpse.particlesRotationY;

            renderer.setClearColor(glimpseBackColor);
            // playSound(theGlimpse.sound);
        }

        function stopGlimpse() {
            kaleidoing = false;
            glimpsing = false;
            // soundObj.pause();
            bringBackPresentGaze();

            if ('morph' in theGlimpse) {
                stopMorph();
            }

            renderer.setClearColor(backColor);
        }

        function startTrip(name) {
            glimpseOn = true;
            alphabetOn = true;
            scheduleVideo(name, 8);

            playSound('transition', true);

            for (var j=0; j<floatingVids.length; j++) {
                sky.remove(floatingVids[j]);
            }

            simulationShader.uniforms.amplitude.value += 10;
            // timer = 200;
            document.body.style.cursor = "url('css/chaos-magick.png'), auto";
            renderShader.uniforms.nColor.value = new THREE.Color(0, 0, 0);
            backColor = new THREE.Color(1, 1, 1);
            renderer.setClearColor(backColor);
        }
        function startKaleido() {
            kaleidoing = true;

            kaleidoscopePass.material.uniforms.sides.value = theGlimpse.kaleido.sides;

            if (Array.isArray(theGlimpse.kaleido.angle))
                kaleidoscopePass.material.uniforms.angle.value = THREE.Math.randFloat(theGlimpse.kaleido.angle[0], theGlimpse.kaleido.angle[1]);
            else {
                kaleidoscopePass.material.uniforms.angle.value = theGlimpse.kaleido.angle;
            }

            if ('uvOffset' in theGlimpse.kaleido) {
                kaleidoscopePass.material.uniforms.uvOffset.value = theGlimpse.kaleido.uvOffset;
            } else if ('uvOffsetRange' in theGlimpse.kaleido) {
                kaleidoscopePass.material.uniforms.uvOffset.value = THREE.Math.randFloat(theGlimpse.kaleido.uvOffsetRange[0], theGlimpse.kaleido.uvOffsetRange[1]);
            }

            if ('diffuseOffset' in theGlimpse.kaleido) {
                kaleidoscopePass.material.uniforms.diffuseOffset.value = theGlimpse.kaleido.diffuseOffset;
            } else if ('diffuseOffsetRange' in theGlimpse.kaleido) {
                kaleidoscopePass.material.uniforms.diffuseOffset.value = THREE.Math.randFloat(theGlimpse.kaleido.diffuseOffsetRange[0], theGlimpse.kaleido.diffuseOffsetRange[1]);
            }
            kaleidoscopePass.material.uniforms.trigoX.value = theGlimpse.kaleido.trigoX !== undefined ? theGlimpse.kaleido.trigoX : THREE.Math.randInt(0, 3);
            kaleidoscopePass.material.uniforms.trigoY.value = theGlimpse.kaleido.trigoY !== undefined ? theGlimpse.kaleido.trigoY : THREE.Math.randInt(0, 3);

            kaleidoscopePass.material.needsUpdate = true;
            // kaleidoscopePass.enabled = true;
        }

        function startMorph(textureDest, speed, pointSize) {
            simulationShader.uniforms.morph.value = 1.0;
            simulationShader.uniforms.textureDest.value = textureDest || getRandImgTexture();
            simulationShader.uniforms.morphTimestamp.value = timer;
            simulationShader.uniforms.morphSpeed.value = speed || 0.8;
            renderShader.uniforms.pointSize.value = pointSize || 4;
            camera.position.set(0., 200., 5.);
        }

        function stopMorph() {
            simulationShader.uniforms.morph.value = 0.0;
        }

        function savePresentGaze() {
            presentGaze.amplitude = simulationShader.uniforms.amplitude.value;
            presentGaze.frequency = simulationShader.uniforms.frequency.value;
            presentGaze.texture = simulationShader.uniforms.texture.value;
            presentGaze.pointSize = renderShader.uniforms.pointSize.value;
            presentGaze.renderColor = renderShader.uniforms.nColor.value;
            presentGaze.backgroundColor = backColor;
            presentGaze.currentRotation = currentRotation;
            presentGaze.cameraPosition = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
            // debugger;
        }

        function bringBackPresentGaze() {
            simulationShader.uniforms.amplitude.value = presentGaze.amplitude;
            simulationShader.uniforms.frequency.value = presentGaze.frequency;
            simulationShader.uniforms.texture.value = presentGaze.texture;
            renderShader.uniforms.pointSize.value = presentGaze.pointSize;
            renderShader.uniforms.nColor.value = presentGaze.renderColor;
            backColor = presentGaze.backgroundColor;
            currentRotation = presentGaze.currentRotation;
            camera.position.set(presentGaze.cameraPosition.x, presentGaze.cameraPosition.y, presentGaze.cameraPosition.z);
        }

        var defaultBackColor=new THREE.Color(0, 0, 0.02), backColor=new THREE.Color(0, 0, 0.02), glimpseBackColor=new THREE.Color(1, 1, 1);
        var defaultParticleColor=new THREE.Color(1, 1, 1), particleColor=new THREE.Color(1, 1, 1), stroboParticleColor=new THREE.Color(0, 0, 0);

        function stroboBackground() {
            let tempBack = glimpseBackColor;
            glimpseBackColor = backColor;
            backColor = tempBack;
            renderer.setClearColor(backColor);
            // let tempParticle = stroboParticleColor;
            // stroboParticleColor = particleColor;
            // particleColor = tempParticle;
            // renderShader.uniforms.nColor.value = particleColor;
        }

        document.addEventListener('mousemove', onDocumentMouseMove, false);

        var mouse = new THREE.Vector2();
        var raycaster = new THREE.Raycaster();

        function onDocumentMouseMove(event) {
            if (videoPlaying) {
                document.body.style.cursor = "url('css/chaos-magick.png'), auto";
                return;
            }

            var mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            // debugger;
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(floatingVids);
            // debugger;
            if (intersects.length) {
                document.body.style.cursor = "pointer";
            } else {
                document.body.style.cursor = "url('css/chaos-magick.png'), auto";
            }
        }

        document.addEventListener('mousedown', onMouseDown, false);
        var raycaster = new THREE.Raycaster();
        function onMouseDown(event) {
            if (videoPlaying) {
                document.body.style.cursor = "url('css/chaos-magick.png'), auto";
                return;
            }
            event.preventDefault();

            var mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(floatingVids);
            if (intersects.length) {
                startTrip(intersects[0].object.vidName);
            }
        }
        var nextVideo, nextVideoCountdown = 0;

        function scheduleVideo(name, time) {
            nextVideo = name;
            nextVideoCountdown = time;
        }

        function playVideo(name) {
            hyperspace(name, renderer, scene);
            delayGlimpseStop(3);
        }

        var glimpseTimer = 0;
        function delayGlimpseStop(time) {
            glimpseTimer = time;
            // theGlimpse.length = 5;
        }

        function hyperspace(name, renderer, scene) {
            hyperspaceOn = true;
            hyperspacing = true;
            var loader = new THREE.TextureLoader();
            loader.crossOrigin = "Anonymous";
            // theGlimpse.length *= 3;
            loader.load(
                "vid/" + name + ".png",
                function(texture) {
                    window.tunnel = new Tunnel(texture, renderer, scene);
                    window.tunnel.vidName = name;
                }
            );
        }

        var glimpseOn = false, alphabetOn = false;
        var stroboHyper = true;
        var hyperspaceOn = false, hyperspacing = false;

        function stopHyperspace() {
            hyperspaceOn = false;
            hyperspacing = false;
            scene.remove(window.tunnel.tubeMesh);
            window.tunnel.stop();

            if (glimpsing)
                stopGlimpse();

            // Queue video
            currVid = vid360.init(renderer, vids[window.tunnel.vidName], Curves);
            currVid.start();
            videoPlaying = true;
        }

        function update() { 
            requestAnimationFrame(update);

            timer += timerInc;
            let timerInt = parseInt(timer);

            simulationShader.uniforms.timer.value = timer;
            renderShader.uniforms.timer.value = timer;
            // simulationShader.uniforms.alphaMap.needsUpdate = true;

            if (glimpseTimer > 0) {
                glimpseTimer -= timerInc;
                if (glimpseTimer <= 0) {
                    glimpseOn = false;
                    alphabetOn = false;
                    hyperspacing = true;
                }
            }

            if (videoPlaying) {
                currVid.update(-0.1);
                if (!currVid.playing) {
                    videoPlaying = false;
                    if (glimpsing)
                        stopGlimpse();
                    // simulationShader.uniforms.amplitude.value = 100;
                    // timer = 200;
                    document.body.style.cursor = "url('css/chaos-magick.png'), auto";
                    renderShader.uniforms.nColor.value = new THREE.Color(1, 1, 1);
                    backColor = new THREE.Color(0, 0, 0);
                    renderer.setClearColor(backColor);
                    for (var j=0; j<floatingVids.length; j++)
                        sky.add(floatingVids[j]);
                }
                if (!glimpseOn)
                    return;
            }

            if (hyperspaceOn) {
                if (typeof window.tunnel !== undefined && window.tunnel.progress() > 0.99) {
                    stopHyperspace();
                    return;
                }
                if (glimpseOn) {
                    var hyperspaceInterval = THREE.Math.randInt(2, 9);
                    if (!hyperspacing && timerInt % hyperspaceInterval == 0) {
                        hyperspacing = true;
                    } else if (hyperspacing && timer % hyperspaceInterval > 1) {
                        hyperspacing = false;
                    }
                }
                if (hyperspacing) {
                    window.tunnel.render();
                    return;
                }
            }

            if (nextVideoCountdown > 0) {
                nextVideoCountdown -= timerInc;
                if (nextVideoCountdown <= 0) {
                    if (!videoPlaying) {
                        playVideo(nextVideo);
                    }
                    // glimpseOn = false;
                }

            }

            //update simulation
            FBO.update();

            if (glimpseOn) {
                // Pick a time interval for how often to start the glimpse effect
                var glimpseInterval = THREE.Math.randInt(1, 9);
                if (timerInt % glimpseInterval == 0) {
                    if (!glimpsing) {
                        startGlimpse();
                    }
                } else if (glimpsing && timer % glimpseInterval > theGlimpse.length * 5) {
                    stopGlimpse();
                }
            }

            if (alphabetOn) {
                var alaphabetInterval = THREE.Math.randInt(2, 9);
                if (!alphabeting && timerInt % alaphabetInterval == 0) {
                    startAlphabet();
                } else if (alphabeting && timer % alaphabetInterval > 3) {
                    stopAlphabet();
                }
                if (alphabeting) {
                    textMaterial.uniforms.timer.value += timerInc;
                    if (textMaterial.uniforms.timer.value > alphabetDuration) {
                        textMaterial.uniforms.timer.value = 0;
                        alphabeting = false;
                    }
                }
            }

            // Constant counter-clockwise rotation, dervish style
            // FBO.particles.rotation.y -= currentRotation;
            for (let j=0; j<floatingVids.length; j++) {
                floatingVids[j].rotation.y -= currentRotation;
            }

            // camera.position.x -= 10 * Math.PI / 180;
            sky.rotation.y -= currentRotation;
            controls.update();

            // If we are in glimpse mode
            // Also check if the kaleido effect is on and call the effect composer
            if (glimpsing) {
                if (theGlimpse.stroboBackground) {
                    stroboBackground();
                }
            } else {
                // When we reach min/max sphere amplitude, reverse
                if (simulationShader.uniforms.amplitude.value < 50 || simulationShader.uniforms.amplitude.value > 150) {
                    amplDec = -amplDec;
                    amplInc = -amplInc;
                }
            }

            if (kaleidoing) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
            renderer.autoClear = false;

            // Increase or decrease the amplitutde cyclically every time unit
            if (timerInt % 2 == 0) {
                simulationShader.uniforms.amplitude.value += amplInc;
            } else if (timerInt % 2 == 1) {
                simulationShader.uniforms.amplitude.value -= amplDec;
            }
        }

        //returns a Float32Array buffer of 3D points after an image
        function getImage(img, elevation){
            var ctx = getContext(null, img.width, img.height);
            ctx.drawImage(img, 0, 0);
            var imgData = ctx.getImageData(0, 0, img.width, img.height);
            var iData = imgData.data;

            var l = (img.width * img.height);
            var data = new Float32Array(l * 3);
            for (var i = 0; i < l; i++) {
                var i3 = i * 3;
                var i4 = i * 4;
                data[i3] = (i % img.width) - img.width * .5;
                data[i3 + 1] = (iData[i4] / 0xFF * 0.299 +iData[i4+1]/0xFF * 0.587 + iData[i4+2] / 0xFF * 0.114) * elevation;
                data[i3 + 2] = (parseInt(i / img.width) - img.height * .5);
            }
            return data;
        }
        function getCanvas(w, h){
            var canvas = document.createElement("canvas");
            canvas.width = w || 512;
            canvas.height = h || 512;
            return canvas;
        }
        function getContext(canvas, w, h){
            canvas = canvas || getCanvas(w, h);
            canvas.width = w || canvas.width;
            canvas.height = h || canvas.height;
            return canvas.getContext("2d");
        }

        function getRandImgTexture() {
            let img = imgs[THREE.Math.randInt(0, imgs.length - 1)];
            let data = getImage(img, 64);
            let texture = new THREE.DataTexture(data, img.width, img.height, THREE.RGBFormat, THREE.FloatType);
            texture.needsUpdate = true;
            return texture;
        }

        async function loadImages(imageUrlArray) {
            const promiseArray = [];
            const imageArray = [];

            for (let imageUrl of imageUrlArray) {
                promiseArray.push(new Promise(resolve => {
                    const img = new Image();
                    img.onload = resolve;
                    img.src = 'img/' + imageUrl;
                    imageArray.push(img);
                }));
            }

            await Promise.all(promiseArray);
            return imageArray;
        }

    </script>
</body>
</html>