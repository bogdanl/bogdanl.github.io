<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>mirrors in space</title>
    <!-- <link href="css/main.css" rel="stylesheet"> -->
<style>
    head, body{
    width:100%;
    height:100%;
    overflow: hidden;
    top:0;
    left:0;
    margin:0;
    padding:0;
    cursor: url('img/chaos-magick.png'), auto;
    font-family: optima;
    color: white;
    text-align: justify;
}
#title {
    position: absolute;
    left: 10px;
    bottom: 10px;
    cursor: url('img/chaos-magick.png'), auto;
    width: 330px;
    text-align: justify;
    text-align-last: justify;
    text-justify: inter-word;
}
#volume {
    position: absolute;
    top: 3px;
    left: 3px;
    font-size: 13px;
    font-style: bold;
    cursor: pointer;
}
#fullscreen {
    position: absolute;
    top: 3px;
    right: 3px;
    cursor: pointer;
}
</style>
</head>
<body>
    <div id="fullscreen">fullscreen</div>
    <div id="title">
        <strong>mirrors in space â˜· coming soon</strong> to be outlived<br>
        by the stairs free falling into the running water<br>
        the stars rolling away from each other<br>
        outshone by silhouettes on fortuitous placards<br>
        & out of sight; forgetful of its smeared desires
    </div>
    <div id="volume">TURN SOUND ON</div>
    <audio id="sound" preload="auto" loop>
      <source src="snd/mirrors_short.ogg" type="audio/ogg">
    </audio>
    <script src="vendor/three.min.js"></script>
    <script src="vendor/OrbitControls.js"></script>
    <script src="ShaderLoader.js"></script>
    <script src="fbo.js"></script>
    <script type="module">
        import {EffectComposer} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/EffectComposer.js';
        import {RenderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/RenderPass.js';
        import {ShaderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/ShaderPass.js';

        var scene, camera, renderer, composer, controls, timer=0, timerInc=.01;
        var simulationShader, renderShader;
        var soundOn=false, audioLoader, soundObj;

        var stroboOn=false, currAmpli, currFrequency, amplInc=0.11, amplDec=0.08;
        var texture, video, videoMaterial, defaultTexture;
        var imgUrls = ['ourobouros.jpeg', 'sigil.jpeg'];
        var imgs = [];

        var stroboFlow = [
            {
                length: 1,
                sound: 'tempo-change',
                amplitude: 10^4, // lots of movement
                frequency: 10^3, // still particles + grid lines
                particlesColor: new THREE.Vector3(0, 0, 0),
                backgroundColor: new THREE.Vector3(1, 1, 1),
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: THREE.Math.randInt(3, 5),
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -.5,
                    diffuseOffset: .5
                }
            },
            {
                length: 1,
                sound: 'tempo-change',
                amplitude: 10^4, // lots of movement
                // frequency: 10^3, // still particles + grid lines
                particlesColor: new THREE.Vector3(0, 0, 0),
                backgroundColor: new THREE.Vector3(1, 1, 1),
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: THREE.Math.randInt(3, 5),
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -.5,
                    diffuseOffset: .5
                }
            }
        ];

        window.onload = function() {
            var sl = new ShaderLoader();
            sl.loadShaders({
                noise_simulationVS : "",
                noise_simulationFS : "",
                noise_renderVS : "",
                noise_renderFS : "",
                image_simulationVS : "",
                image_simulationFS : "",
                image_renderVS : "",
                image_renderFS : ""
            }, "./glsl/", init );
        };

        function playSound(name, volume) {
            if (!soundOn) {
                return;
            }
            audioLoader.load('snd/' + name + '.ogg', function(buffer) {
                soundObj.setBuffer(buffer);
                soundObj.setLoop(false);
                soundObj.setVolume(volume || 0.8);
                soundObj.play();
            });

        }

        function playVideo() {
            video = document.getElementById('video');
            texture = new THREE.VideoTexture(video);
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.format = THREE.RGBFormat;

            videoMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });

            var imageObject = new THREE.Mesh(
                new THREE.PlaneGeometry(256, 128),
                videoMaterial,
            );

            scene.add(imageObject);

            // video.src = "pantarei.mp4";
            // video.load();
            video.style.visibility = 'visible';
            video.muted = false;
            video.play();
        }

        //returns a Float32Array buffer of random 3D coordinates
        function getRandomData( width, height, size ){
            var len = width * height * 3;
            var data = new Float32Array( len );
            while( len-- )data[len] = ( Math.random() -.5 ) * size ;
            return data;
        }

        function getDefaultTexture(width, height, size) {
            let data = getSphere(width * height, size);
            let texture = new THREE.DataTexture(
                data, width, height, THREE.RGBFormat, THREE.FloatType, THREE.DEFAULT_MAPPING, THREE.MirroredRepeatWrapping, THREE.MirroredRepeatWrapping
                );
            texture.needsUpdate = true;
            return texture;
        }

        function init(args) {
            loadImages(imgUrls).then(images => {
                imgs = images;
                initCont(args);
            });

        }

        function initCont(args) {
            args = args || {};
            var w = window.innerWidth;
            var h = window.innerHeight;
            renderer = new THREE.WebGLRenderer({
                logarithmicDepthBuffer: true,
                antialias: true
            });
            renderer.setSize(w, h);
            renderer.setClearColor(defaultBackColor);

            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(100, 0, 0.0001, 10000);

            controls = new THREE.OrbitControls(camera);
            camera.position.z =  30;

            // create an AudioListener and add it to the camera
            var listener = new THREE.AudioListener();
            camera.add(listener);
            // create a global audio source
            soundObj = new THREE.Audio(listener);
            // load a sound and set it as the Audio object's buffer
            audioLoader = new THREE.AudioLoader();

            var ww = 512;
            var width  = args.w || ww;
            var height = args.h || ww;

            defaultTexture = getDefaultTexture(width, height, args.s || 2500);

            simulationShader = new THREE.ShaderMaterial({
                uniforms: {
                    texture: { type: "t", value: defaultTexture },
                    timer: { type: "f", value: 0},
                    frequency: { type: "f", value: 0.00032 },
                    amplitude: { type: "f", value: 60 },
                    maxDistance: { type: "f", value: 48 },
                    morph: {type: 'f', value: 0.0 },
                    textureDest: { type: "t", value: null },
                    morphTimestamp: { type: 'f', value: null },
                    morphSpeed: { type: 'f', value: 0.1 },
                },
                vertexShader: ShaderLoader.get( "noise_simulationVS"),
                fragmentShader:  ShaderLoader.get( "noise_simulationFS")
            });

            renderShader = new THREE.ShaderMaterial( {
                uniforms: {
                    positions: { type: "t", value: null },
                    pointSize: { type: "f", value: 3 },
                    nColor: { type: "v3", value: new THREE.Vector3(1, 1, 1) },
                    big: { type: "v3", value: new THREE.Vector3(207, 221, 212).multiplyScalar(1/0xFF) },
                    small: { type: "v3", value: new THREE.Vector3(213, 239, 229).multiplyScalar(1/0xFF) },
                },
                vertexShader: ShaderLoader.get( "noise_renderVS"),
                fragmentShader: ShaderLoader.get( "noise_renderFS"),
                transparent: true,
                side:THREE.DoubleSide,
                // blending:THREE.AdditiveBlending
            });

            const kaleidoscopeShader = {
                uniforms: {
                  "tDiffuse": { value: null },
                  "sides": { value: 1.0 },
                  "angle": { value: 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;

                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float sides;
                    uniform float angle;
                    varying vec2 vUv;
                    const float tau = 2. * 3.1415926535897932384626433832795;
                    void main() {
                        vec2 p = vUv - .5;
                        float r = length(p);
                        float a = atan(p.x, p.y) + angle;
                        a = mod(a, tau/sides);
                        a = abs(a - tau/sides/2.) ;
                        p = r * vec2(sin(a), cos(a));
                        vec4 color = texture2D(tDiffuse, p + .5);
                        gl_FragColor = color;
                    }
                `
              };


            FBO.init(width,height, renderer, simulationShader, renderShader);
            scene.add(FBO.particles);

            addDomListeners();

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const kaleidoscopePass = new ShaderPass(kaleidoscopeShader);
            kaleidoscopePass.renderToScreen = true;
            composer.addPass(kaleidoscopePass);

            onResize();
            update();
        }

        function addDomListeners() {
            window.addEventListener("resize", onResize);

            var volumeButton = document.getElementById('volume');
            volumeButton.addEventListener('click', function(event) {
                let soundOgg = document.getElementById('sound');
                if (!soundOn) {
                    soundOgg.play();
                    volumeButton.innerHTML = "TURN SOUND OFF";
                    soundOn = true;
                }
                else {
                    soundOgg.pause();
                    soundOgg.currentTime = 0;
                    volumeButton.innerHTML = "TURN SOUND ON";
                    soundOn = false;
                }
            });
            window.addEventListener("resize", onResize);
            
            var goFS = document.getElementById("fullscreen");
            goFS.addEventListener("click", function() {
              document.body.requestFullscreen();
            }, false);
        }

        function getSpherePoint(point, size){
            point.x = Math.random() * 2 - 1;
            point.y = Math.random() * 2 - 1;
            point.z = Math.random() * 2 - 1;

            if(point.length() > 1) {
                return getSpherePoint(point, size);
            }
            return point.normalize().multiplyScalar(size);
        }

        //returns a Float32Array buffer of spherical 3D points
        function getSphere(count, size){
            var len = count * 3;
            var data = new Float32Array(len);
            var point = new THREE.Vector3();
            for(var i = 0; i < len; i += 3){
                getSpherePoint(point, size);
                data[i] = point.x;
                data[i + 1] = point.y;
                data[i + 2] = point.z;
            }
            return data;
        }

        function onResize(){
            var w = window.innerWidth;
            var h = window.innerHeight;
            renderer.setSize(w, h);
            composer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }

        var currentRender = {};
        var morphRender = {};
        var stroboCount = 0;

        function startMorph() {
            simulationShader.uniforms.morph.value = 1.0;
            simulationShader.uniforms.textureDest.value = getRandImgTexture();
            simulationShader.uniforms.morphTimestamp.value = timer;
            simulationShader.uniforms.morphSpeed.value = 0.8;
            renderShader.uniforms.pointSize.value = 5;
        }

        function stopMorph() {
            simulationShader.uniforms.morph.value = 0.0;
        }

        function saveCurrentRender() {
            currentRender.amplitude = simulationShader.uniforms.amplitude.value;
            currentRender.frequency = simulationShader.uniforms.frequency.value;
            currentRender.texture = simulationShader.uniforms.texture.value;
            currentRender.pointSize = renderShader.uniforms.pointSize.value;
            currentRender.renderColor = renderShader.uniforms.nColor.value;
            currentRender.backgroundColor = backColor;
        }

        function restoreCurrentRender() {
            simulationShader.uniforms.amplitude.value = currentRender.amplitude;
            simulationShader.uniforms.frequency.value = currentRender.frequency;
            simulationShader.uniforms.texture.value = currentRender.texture;
            renderShader.uniforms.pointSize.value = currentRender.pointSize;
            renderShader.uniforms.nColor.value = currentRender.renderColor
            backColor = currentRender.backgroundColor;
        }

        function startStrobo() {
            playSound('tempo-change');
            stroboOn = true;
            stroboCount += 1;

            saveCurrentRender();

            // startMorph();

            simulationShader.uniforms.amplitude.value = 1000000.1;
            if (stroboCount % 2 == 0) {
                simulationShader.uniforms.frequency.value = 10000.1;
            } else {
                simulationShader.uniforms.frequency.value = 0.00032;
            }
            // simulationShader.uniforms.frequency.value = 10000.1;
            // renderShader.uniforms.pointSize.value = THREE.Math.randInt(3, 4);
            // renderShader.uniforms.nColor.value = new THREE.Vector3(Math.random(), Math.random(), Math.random());

            renderShader.uniforms.nColor.value = stroboParticleColor;
            renderer.setClearColor(stroboBackColor);

        }

        function stopStrobo() {
            stroboOn = false;
            soundObj.pause();

            // stopMorph();
            
            restoreCurrentRender();
            renderer.setClearColor(backColor);
        }

        var defaultBackColor=new THREE.Color(0, 0, 0.02), backColor=new THREE.Color(0, 0, 0.02), stroboBackColor=new THREE.Color(1, 1, 1);
        var defaultParticleColor=new THREE.Color(1, 1, 1), particleColor=new THREE.Color(1, 1, 1), stroboParticleColor=new THREE.Color(0, 0, 0);

        function stroboBackground() {
            let tempBack = stroboBackColor;
            stroboBackColor = backColor;
            backColor = tempBack;
            renderer.setClearColor(backColor);

            // let tempParticle = stroboParticleColor;
            // stroboParticleColor = particleColor;
            // particleColor = tempParticle;
            // renderShader.uniforms.nColor.value = particleColor;
        }

        function update()
        { 
            requestAnimationFrame(update);
            controls.update();

            //update simulation
            FBO.update();

            timer += timerInc;
            let timerInt = parseInt(timer);

            simulationShader.uniforms.timer.value = timer;
            // FBO.particles.rotation.x = Math.cos( Date.now() *.001 ) * Math.PI / 180 * 2;

            // Constant counter-clockwise rotation, dervish style
            FBO.particles.rotation.y -= Math.PI / 180 * .3;

            // If we are in strobo mode, flicker the background
            // Also check if the kaleido effect is on and call the effect composer
            if (stroboOn) {
                // FBO.particles.rotation.y += Math.PI / 180 * .6;
                if (stroboCount % 3 == 0) {
                    composer.render();
                } else {
                    renderer.render(scene, camera);
                }
                stroboBackground();
            } else {
                renderer.render(scene, camera);
            }

            // Pick a time interval for how often to start the strobo effect
            // var stroboInterval = THREE.Math.randInt(4, 8);
            var stroboInterval = 5;
            if (timer > 1 && timerInt % stroboInterval == 0) {
                if (!stroboOn) {
                    startStrobo();
                }
            } else if (stroboOn && timer % stroboInterval > 1) {
                stopStrobo();
            }

            // Increase or decrease the amplitutde cyclically every time unit
            if (timerInt % 2 == 0) {
                simulationShader.uniforms.amplitude.value += amplInc;
            } else if (timerInt % 2 == 1) {
                simulationShader.uniforms.amplitude.value -= amplDec;
            }

            // When we reach min/max sphere amplitude, go in reverse
            if (simulationShader.uniforms.amplitude.value < 60 || simulationShader.uniforms.amplitude.value > 150) {
                amplDec = -amplDec;
                amplInc = -amplInc;
            }
        }

        //returns a Float32Array buffer of 3D points after an image
        function getImage(img, elevation){
            var ctx = getContext( null, img.width, img.height );
            ctx.drawImage(img, 0, 0);
            var imgData = ctx.getImageData(0,0,img.width,img.height);
            var iData = imgData.data;

            var l = (img.width * img.height);
            var data = new Float32Array(l * 3);
            for (var i = 0; i < l; i++) {
                var i3 = i * 3;
                var i4 = i * 4;
                data[ i3 ]      = ( ( i % img.width ) - img.width  * .5 );
                data[ i3 + 1 ]  = (iData[i4] / 0xFF * 0.299 +iData[i4+1]/0xFF * 0.587 + iData[i4+2] / 0xFF * 0.114 ) * elevation;
                data[ i3 + 2 ]  = (parseInt(i / img.width ) - img.height * .5);
            }
            return data;
        }
        function getCanvas( w,h ){

            var canvas = document.createElement( "canvas");
            canvas.width = w || 512;
            canvas.height = h || 512;
            return canvas;
        }
        function getContext( canvas, w,h ){

            canvas = canvas || getCanvas(w,h);
            canvas.width = w || canvas.width;
            canvas.height = h || canvas.height;
            return canvas.getContext("2d");
        }

        function getRandImgTexture() {
            let img = imgs[THREE.Math.randInt(0, imgs.length - 1)];
            let data = getImage(img, 64);
            let texture = new THREE.DataTexture(data, img.width, img.height, THREE.RGBFormat, THREE.FloatType);
            texture.needsUpdate = true;
            return texture;
        }

        async function loadImages(imageUrlArray) {
            const promiseArray = []; // create an array for promises
            const imageArray = []; // array for the images

            for (let imageUrl of imageUrlArray) {

                promiseArray.push(new Promise(resolve => {

                    const img = new Image();
                    // if you don't need to do anything when the image loads,
                    // then you can just write img.onload = resolve;

                    img.onload = function() {
                        // do stuff with the image if necessary

                        // resolve the promise, indicating that the image has been loaded
                        resolve();
                    };

                    img.src = 'img/' + imageUrl;
                    imageArray.push(img);
                }));
            }

            await Promise.all(promiseArray); // wait for all the images to be loaded
            console.log("all images loaded");
            return imageArray;
        }

    </script>
</body>
</html>