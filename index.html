<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>mirrors in space</title>
    <!-- <link href="css/main.css" rel="stylesheet"> -->
<style>
    head, body{
    width:100%;
    height:100%;
    overflow: hidden;
    top:0;
    left:0;
    margin:0;
    padding:0;
    cursor: url('img/chaos-magick.png'), auto;
    font-family: optima;
    color: white;
    text-align: justify;
}
#title {
    position: absolute;
    left: 10px;
    bottom: 10px;
    cursor: url('img/chaos-magick.png'), auto;
    width: 330px;
    text-align: justify;
    text-align-last: justify;
    text-justify: inter-word;
}
#volume {
    position: absolute;
    top: 3px;
    left: 3px;
    font-size: 13px;
    font-style: bold;
    cursor: pointer;
}
#fullscreen {
    position: absolute;
    top: 3px;
    right: 3px;
    cursor: pointer;
}
</style>
</head>
<body>
    <div id="fullscreen">fullscreen</div>
    <div id="title">
        <strong>mirrors in space â˜· coming soon</strong> to be outlived<br>
        by the stairs free falling into the running water<br>
        the stars rolling away from each other<br>
        outshone by silhouettes on fortuitous placards<br>
        & out of sight; forgetful of its smeared desires
    </div>
    <div id="volume">TURN SOUND ON</div>
    <audio id="sound" preload="auto" loop>
      <source src="snd/mirrors_short.ogg" type="audio/ogg">
    </audio>
<!--         <video id="video" loop muted style="display:none; position: absolute; width: 640px; height: 360px;left: 200px;top: 100px;">
            <source src="vid/altaic2_.mp4" type='video/mp4;'>
        </video>
 -->
    <script src="vendor/three.min.js"></script>
    <script src="vendor/OrbitControls.js"></script>
    <script src="ShaderLoader.js"></script>
    <script src="fbo.js"></script>
    <script type="module">
        import {EffectComposer} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/EffectComposer.js';
        import {RenderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/RenderPass.js';
        import {ShaderPass} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/postprocessing/ShaderPass.js';

        var scene, camera, renderer, composer, controls, timer=0, timerInc=.01;
        var simulationShader, renderShader;
        var soundOn=false, audioLoader, soundObj;

        var stroboOn=false, currAmpli, currFrequency, amplInc=0.11, amplDec=0.08;
        var defaultBackColor=new THREE.Color(0, 0, 0.02), backColor=new THREE.Color(0, 0, 0.02), stroboBackColor=new THREE.Color(1, 1, 1);
        var stages = [{frequency: 0.0005, timer: 0.01, amplitude: 96, maxDistance: 48}];
        var texture, video, videoMaterial, img;

        var stroboFlow = [
            {
                length: 1,
                sound: 'tempo-change',
                amplitude: 10^4, // lots of movement
                frequency: 10^3, // still particles + grid lines
                particlesColor: new THREE.Vector3(0, 0, 0),
                backgroundColor: new THREE.Vector3(1, 1, 1),
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: THREE.Math.randInt(3, 5),
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -.5,
                    diffuseOffset: .5
                }
            },
            {
                length: 1,
                sound: 'tempo-change',
                amplitude: 10^4, // lots of movement
                // frequency: 10^3, // still particles + grid lines
                particlesColor: new THREE.Vector3(0, 0, 0),
                backgroundColor: new THREE.Vector3(1, 1, 1),
                particlesRotationY: Math.PI / 180 * .3, // left or k-inwards
                pointSize: THREE.Math.randInt(3, 5),
                kaleido: {
                    sides: 1.,
                    angle: 0.,
                    uvOffset: -.5,
                    diffuseOffset: .5
                }
            }
        ];

        window.onload = function() {
            var sl = new ShaderLoader();
            sl.loadShaders({
                simulation_vs : "",
                simulation_fs : "",
                render_vs : "",
                render_fs : ""
            }, "./glsl/noise/", init );
        };

        function playSound(name) {
            if (!soundOn) {
                return;
            }
            audioLoader.load('snd/' + name + '.ogg', function(buffer) {
                soundObj.setBuffer(buffer);
                soundObj.setLoop(false);
                soundObj.setVolume(0.8);
                soundObj.play();
            });

        }

        function playVideo() {

            video = document.getElementById('video');
            texture = new THREE.VideoTexture(video);
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.format = THREE.RGBFormat;

            videoMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });

            var imageObject = new THREE.Mesh(
                new THREE.PlaneGeometry(256, 128),
                videoMaterial,
            );

            scene.add(imageObject);

            // video.src = "pantarei.mp4";
            // video.load();
            video.style.visibility = 'visible';
            video.muted = false;
            video.play();
        }

        function init(args)
        {
            args = args || {};
            var w = window.innerWidth;
            var h = window.innerHeight;
            renderer = new THREE.WebGLRenderer({
                logarithmicDepthBuffer: true,
                antialias: true
            });
            renderer.setSize(w, h);
            renderer.setClearColor(defaultBackColor);

            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(100, 0, 0.0001, 10000);

            controls = new THREE.OrbitControls(camera);
            camera.position.z =  30;

            // create an AudioListener and add it to the camera
            var listener = new THREE.AudioListener();
            camera.add(listener);
            // create a global audio source
            soundObj = new THREE.Audio(listener);
            // load a sound and set it as the Audio object's buffer
            audioLoader = new THREE.AudioLoader();

            var ww = 512;
            var width  = args.w || ww;
            var height = args.h || ww;

            var data = getSphere(width * height, args.s || 2500);
            var texture = new THREE.DataTexture(
                data, width, height, THREE.RGBFormat, THREE.FloatType, THREE.DEFAULT_MAPPING, THREE.MirroredRepeatWrapping, THREE.MirroredRepeatWrapping
                );
            // playVideo();
            // video = document.getElementById('video');
            // texture = new THREE.VideoTexture(video);
            // texture.minFilter = THREE.NearestFilter;
            // texture.magFilter = THREE.NearestFilter;
            // texture.format = THREE.RGBFormat;

            // videoMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });

            // var imageObject = new THREE.Mesh(
            //     new THREE.PlaneGeometry(256, 128),
            //     videoMaterial,
            // );

            // // video.src = "pantarei.mp4";
            // // video.load();
            // video.style.visibility = 'visible';
            // video.muted = false;

            // img = loadImage('altaic.png');
            // width = img.width;
            // height = img.height;
            // var data = getImage( img, width, height, 64 );
            // var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat, THREE.FloatType );
            // texture.needsUpdate = true;

            simulationShader = new THREE.ShaderMaterial({
                uniforms: {
                    texture: { type: "t", value: texture },
                    timer: { type: "f", value: 0},
                    frequency: { type: "f", value: 0.00032 },
                    amplitude: { type: "f", value: 60 },
                    maxDistance: { type: "f", value: 48 }
                },
                vertexShader: ShaderLoader.get( "simulation_vs"),
                fragmentShader:  ShaderLoader.get( "simulation_fs")
            });

            renderShader = new THREE.ShaderMaterial( {
                uniforms: {
                    positions: { type: "t", value: null },
                    pointSize: { type: "f", value: 3 },
                    nColor: { type: "v3", value: new THREE.Vector3(1, 1, 1) },
                    big: { type: "v3", value: new THREE.Vector3(207, 221, 212).multiplyScalar(1/0xFF) },
                    small: { type: "v3", value: new THREE.Vector3(213, 239, 229).multiplyScalar(1/0xFF) },
                },
                vertexShader: ShaderLoader.get( "render_vs"),
                fragmentShader: ShaderLoader.get( "render_fs"),
                transparent: true,
                side:THREE.DoubleSide
                // blending:THREE.AdditiveBlending
            });

            const kaleidoscopeShader = {
                uniforms: {
                  "tDiffuse": { value: null },
                  "sides": { value: 1.0 },
                  "angle": { value: 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;

                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float sides;
                    uniform float angle;
                    varying vec2 vUv;
                    const float tau = 2. * 3.1415926535897932384626433832795;
                    void main() {
                        vec2 p = vUv - .5;
                        float r = length(p);
                        float a = atan(p.x, p.y) + angle;
                        a = mod(a, tau/sides);
                        a = abs(a - tau/sides/2.) ;
                        p = r * vec2(sin(a), cos(a));
                        vec4 color = texture2D(tDiffuse, p + .5);
                        gl_FragColor = color;
                    }
                `
              };


            FBO.init(width,height, renderer, simulationShader, renderShader);
            scene.add(FBO.particles);

            addDomListeners();

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const kaleidoscopePass = new ShaderPass(kaleidoscopeShader);
            kaleidoscopePass.renderToScreen = true;
            composer.addPass(kaleidoscopePass);

            onResize();
            update();
        }

        function addDomListeners() {
            window.addEventListener("resize", onResize);

            var volumeButton = document.getElementById('volume');
            volumeButton.addEventListener('click', function(event) {
                let soundOgg = document.getElementById('sound');
                if (!soundOn) {
                    soundOgg.play();
                    volumeButton.innerHTML = "TURN SOUND OFF";
                    soundOn = true;
                }
                else {
                    soundOgg.pause();
                    soundOgg.currentTime = 0;
                    volumeButton.innerHTML = "TURN SOUND ON";
                    soundOn = false;
                }
            });
            window.addEventListener("resize", onResize);
            
            var goFS = document.getElementById("fullscreen");
            goFS.addEventListener("click", function() {
              document.body.requestFullscreen();
            }, false);
        }

        function getSpherePoint(point, size){
            point.x = Math.random() * 2 - 1;
            point.y = Math.random() * 2 - 1;
            point.z = Math.random() * 2 - 1;

            if(point.length() > 1) {
                return getSpherePoint(point, size);
            }
            return point.normalize().multiplyScalar(size);
        }

        //returns a Float32Array buffer of spherical 3D points
        function getSphere(count, size){
            var len = count * 3;
            var data = new Float32Array(len);
            var point = new THREE.Vector3();
            for(var i = 0; i < len; i += 3){
                getSpherePoint(point, size);
                data[i] = point.x;
                data[i + 1] = point.y;
                data[i + 2] = point.z;
            }
            return data;
        }

        function onResize(){
            var w = window.innerWidth;
            var h = window.innerHeight;
            renderer.setSize(w, h);
            composer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }

        function stroboBackground() {
            let temp = stroboBackColor;
            stroboBackColor = backColor;
            backColor = temp;
            renderer.setClearColor(backColor);
        }

        var linesOn=0, kaleidoOn=0;

        function startStrobo() {
            playSound('tempo-change');
            stroboOn = true;
            currAmpli = simulationShader.uniforms.amplitude.value;
            currFrequency = simulationShader.uniforms.frequency.value;
            simulationShader.uniforms.amplitude.value = 1000000.1;
            if (linesOn % 0 == 1) {
                simulationShader.uniforms.frequency.value = 10000.1;
            } else {
                simulationShader.uniforms.frequency.value = 0.00032;
            }
            // simulationShader.uniforms.frequency.value = 10000.1;
            renderShader.uniforms.pointSize.value = THREE.Math.randInt(3, 5);
            renderShader.uniforms.nColor.value = new THREE.Vector3(0, 0, 0);
            // renderShader.uniforms.nColor.value = new THREE.Vector3(Math.random(), Math.random(), Math.random());

            // var data = getImage( img, width, height, 64 );
            // var imgTexture = new THREE.DataTexture( data, width, height, THREE.RGBFormat, THREE.FloatType );
            // imgTexture.needsUlepdate = true;
            // simulationShader.uniforms.texture.value = imgTexture;

            renderer.setClearColor(stroboBackColor);

        }

        function stopStrobo() {
            stroboOn = false;
            // kaleidoOn *= -1;
            // linesOn *= -1;
            linesOn += 1;
            kaleidoOn += 1;
            soundObj.pause();
            backColor = defaultBackColor;
            simulationShader.uniforms.amplitude.value = currAmpli;
            simulationShader.uniforms.frequency.value = currFrequency;
            renderShader.uniforms.pointSize.value = 3;
            renderShader.uniforms.nColor.value = new THREE.Vector3(1, 1, 1);
            renderer.setClearColor(backColor);
        }

        function update()
        { 
            requestAnimationFrame(update);
            controls.update();

            //update simulation
            FBO.update();
            renderer.render(scene, camera);
            timer += timerInc;
            let timerInt = parseInt(timer);

            simulationShader.uniforms.timer.value = timer;
            // FBO.particles.rotation.x = Math.cos( Date.now() *.001 ) * Math.PI / 180 * 2;

            // Constant counter-clockwise rotation, dervish style
            FBO.particles.rotation.y -= Math.PI / 180 * .3;

            // If we are in strobo mode, flicker the background
            // Also check if the kaleido effect is on and call the effect composer
            if (stroboOn) {
                FBO.particles.rotation.y += Math.PI / 180 * .6;
                if (kaleidoOn % 3 == 1) {
                    composer.render();
                } else {
                    renderer.render(scene, camera);
                }
                // renderer.render(scene, camera);
                stroboBackground();
            } else {
                renderer.render(scene, camera);
            }

            // Pick a time interval for how often to start the strobo effect
            // var stroboInterval = THREE.Math.randInt(4, 8);
            var stroboInterval = 5;
            if (timer > 1 && timerInt % stroboInterval == 0) {
                if (!stroboOn) {
                    startStrobo();
                }
            } else if (stroboOn && timer % stroboInterval > 0) {
                stopStrobo();
            }

            // Increase or decrease the amplitutde cyclically every time unit
            if (timerInt % 2 == 0) {
                simulationShader.uniforms.amplitude.value += amplInc;
            } else if (timerInt % 2 == 1) {
                simulationShader.uniforms.amplitude.value -= amplDec;
            }

            // When we reach min/max sphere amplitude, go in reverse
            if (simulationShader.uniforms.amplitude.value < 60 || simulationShader.uniforms.amplitude.value > 150) {
                amplDec = -amplDec;
                amplInc = -amplInc;
            }
        }

        //returns a Float32Array buffer of 3D points after an image
        function getImage( img, width, height, elevation ){
            var ctx = getContext( null, width, height );
            ctx.drawImage(img, 0, 0);

            var imgData = ctx.getImageData(0,0,width,height);
            var iData = imgData.data;

            var l = (width * height);
            var data = new Float32Array(l * 3);
            for (var i = 0; i < l; i++) {
                var i3 = i * 3;
                var i4 = i * 4;
                data[ i3 ]      = ( ( i % width ) - width  * .5 );
                data[ i3 + 1 ]  = (iData[i4] / 0xFF * 0.299 +iData[i4+1]/0xFF * 0.587 + iData[i4+2] / 0xFF * 0.114 ) * elevation;
                data[ i3 + 2 ]  = (parseInt(i / width ) - height * .5);
            }
            return data;
        }

        function getCanvas(w, h){
            var canvas = document.createElement( "canvas");
            canvas.width = w || 512;
            canvas.height = h || 512;
            return canvas;
        }

        function getContext(canvas, w, h){
            canvas = canvas || getCanvas(w, h);
            canvas.width = w || canvas.width;
            canvas.height = h || canvas.height;
            return canvas.getContext("2d");
        }

        function loadImage(name){
            var img = new Image();
            img.onload = function(e)
            {
                init(e.target);
            };
            debugger;
            img.crossOrigin = "anonymous";
            img.src = "img/focus.jpeg";
            return img;
        }

    </script>
</body>
</html>